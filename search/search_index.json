{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>hotspot_socks_proxy<ul> <li>cmd<ul> <li>cli</li> <li>find_wifi</li> <li>http_handler</li> <li>http_proxy</li> <li>http_server</li> <li>socks</li> </ul> </li> <li>core<ul> <li>exceptions</li> <li>lib<ul> <li>dns_handler</li> <li>proxy_server</li> <li>proxy_stats</li> <li>socks_handler</li> </ul> </li> <li>network</li> <li>proxy</li> <li>utils<ul> <li>prompt<ul> <li>prompt</li> <li>proxy_ui</li> <li>socks_ui</li> </ul> </li> <li>utils</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/hotspot_socks_proxy/","title":"hotspot_socks_proxy","text":""},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy","title":"<code>hotspot_socks_proxy</code>","text":"<p>SOCKS proxy for routing traffic through WiFi interface.</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.get_version","title":"<code>get_version()</code>","text":"<p>Read version from pyproject.toml.</p> Source code in <code>src/hotspot_socks_proxy/__init__.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"Read version from pyproject.toml.\"\"\"\n    current_dir = pathlib.Path(__file__).parent\n    parents = [current_dir, *list(current_dir.parents)]  # Use list unpacking\n\n    for parent in parents:\n        pyproject_path = parent / \"pyproject.toml\"\n        if pyproject_path.exists():\n            with pyproject_path.open(\"rb\") as f:\n                pyproject_data = tomllib.load(f)\n            return pyproject_data[\"project\"][\"version\"]\n\n    return \"0.0.0\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd","title":"<code>cmd</code>","text":"<p>Command line interface modules.</p> <p>This package provides the command-line tools and utilities for: - Starting and managing proxy servers - Finding and configuring network interfaces - Displaying server statistics - Managing server processes - Error reporting and logging</p> <p>The command modules provide user-friendly interfaces to the core proxy server functionality, making it easy to start and manage proxy servers from the command line.</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.cli","title":"<code>cli</code>","text":"<p>Command-line interface for the SOCKS proxy server.</p> <p>This module provides the main command-line interface for the proxy server, handling: - Command-line argument parsing - Server initialization - Process management - Root privilege checking - Error reporting - Interface selection</p> <p>The CLI is built using Typer and provides a user-friendly interface for: - Starting the proxy server - Configuring the number of worker processes - Setting the listening port - Managing server lifecycle</p> Example Functions <code>check_root()</code> <p>Check if the script is running with root privileges.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>def check_root() -&gt; bool:\n    \"\"\"Check if the script is running with root privileges.\"\"\"\n    if os.name == \"nt\":  # Windows\n        try:\n            import ctypes\n\n            return ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception:\n            return False\n    else:  # Unix-like\n        return os.geteuid() == 0\n</code></pre> <code>start_proxy(processes=typer.Option(None, '--processes', '-p', help='Number of CPU processes (default: CPU count)'), port=typer.Option(9050, '--port', help='Port to listen on'))</code> <p>Start the SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.command(name=\"proxy\")\ndef start_proxy(\n    processes: int | None = typer.Option(\n        None, \"--processes\", \"-p\", help=\"Number of CPU processes (default: CPU count)\"\n    ),\n    port: int = typer.Option(9050, \"--port\", help=\"Port to listen on\"),\n):\n    \"\"\"Start the SOCKS proxy server.\"\"\"\n    if not check_root():\n        console.print(\"[red]This program requires root privileges to run properly.\")\n        console.print(\"[yellow]Please run with sudo or as root.\")\n        sys.exit(1)\n\n    # Get available interfaces\n    interface = scan_interfaces()\n    if not interface:\n        console.print(\"[red]No suitable network interface found\")\n        return\n\n    try:\n        # Convert None to CPU count before passing to create_proxy_server\n        process_count = processes if processes is not None else os.cpu_count() or 1\n        create_proxy_server(interface.ip, port, process_count)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre> <code>version_callback()</code> <p>Show version information.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef version_callback():\n    \"\"\"Show version information.\"\"\"\n    console.print(f\"[cyan]Hotspot SOCKS Proxy v{__version__}[/cyan]\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.cli--run-from-command-line","title":"Run from command line:","text":"<p>$ python -m hotspot_socks_proxy proxy --port 9050 --processes 4</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.find_wifi","title":"<code>find_wifi</code>","text":"<p>WiFi interface detection and information display.</p> <p>This module provides functionality for: - Detecting WiFi interfaces - Gathering interface information - Displaying interface details - MAC address lookup - Status checking</p> <p>The module uses system commands to gather detailed information about WiFi interfaces and presents it in a formatted table using Rich.</p> Example Functions <code>get_interface_info()</code> <p>Get information about the network interface.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def get_interface_info() -&gt; dict[str, str]:\n    \"\"\"Get information about the network interface.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    result = subprocess.run(\n        [str(Path(\"/sbin/ifconfig\")), \"en0\"],\n        capture_output=True,\n        text=True,\n        check=False,\n    )\n    if result.returncode != 0:\n        return {\"ip\": \"Not found\", \"mac\": \"Not found\", \"status\": \"Error\"}\n\n    output = result.stdout\n\n    # Parse interface information\n    ip_match = re.search(r\"inet (\\d+\\.\\d+\\.\\d+\\.\\d+)\", output)\n    mac_match = re.search(r\"ether (\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w)\", output)\n    status_match = re.search(r\"status: (\\w+)\", output)\n\n    return {\n        \"ip\": ip_match.group(1) if ip_match else \"Not found\",\n        \"mac\": mac_match.group(1) if mac_match else \"Not found\",\n        \"status\": status_match.group(1) if status_match else \"Unknown\",\n    }\n</code></pre> <code>show_wifi_info()</code> <p>Display WiFi interface information and return the interface details.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def show_wifi_info() -&gt; dict[str, str]:\n    \"\"\"Display WiFi interface information and return the interface details.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    info = get_interface_info()\n\n    table = Table(title=\"WiFi Interface (en0) Information\")\n    table.add_column(\"Property\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n\n    table.add_row(\"IP Address\", info[\"ip\"])\n    table.add_row(\"MAC Address\", info[\"mac\"])\n    table.add_row(\"Status\", info[\"status\"])\n\n    console.print(table)\n    return info\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.find_wifi--show-information-about-the-wifi-interface","title":"Show information about the WiFi interface","text":"<p>show_wifi_info()</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.http_handler","title":"<code>http_handler</code>","text":"<p>HTTP handler implementation.</p> Classes <code>HTTPProxy</code> <p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: The connected client socket\n            _client_address: Tuple of (host, port) representing client address\n        \"\"\"\n        remote_socket = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n            url = first_line.split(\" \")[1]\n\n            # Extract hostname and port\n            http_pos = url.find(\"://\")\n            temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n            port_pos = temp.find(\":\")\n            webserver_pos = temp.find(\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            if port_pos == -1 or webserver_pos &lt; port_pos:\n                port = 80\n                webserver = temp[:webserver_pos]\n            else:\n                port = int(temp[(port_pos + 1) : webserver_pos])\n                webserver = temp[:port_pos]\n\n            # Connect to remote server\n            remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            remote_socket.connect((webserver, port))\n            remote_socket.send(request)\n\n            # Forward data between client and remote server\n            while True:\n                # Use proper type hints for select results\n                readable_sockets, _, _ = cast(\n                    tuple[\n                        list[socket.socket], list[socket.socket], list[socket.socket]\n                    ],\n                    select.select([client_socket, remote_socket], [], [], 3),\n                )\n                if not readable_sockets:\n                    break\n\n                for sock in readable_sockets:\n                    other = remote_socket if sock is client_socket else client_socket\n                    try:\n                        data = sock.recv(4096)\n                        if not data:\n                            return\n                        other.send(data)\n                    except OSError:\n                        return\n\n        except OSError as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if remote_socket:\n                remote_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    thread = threading.Thread(\n                        target=self.handle_client,\n                        args=(client_socket, client_address),\n                        daemon=True,\n                    )\n                    thread.start()\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _client_address)</code> <p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>The connected client socket</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Tuple of (host, port) representing client address</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: The connected client socket\n        _client_address: Tuple of (host, port) representing client address\n    \"\"\"\n    remote_socket = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n        url = first_line.split(\" \")[1]\n\n        # Extract hostname and port\n        http_pos = url.find(\"://\")\n        temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n        port_pos = temp.find(\":\")\n        webserver_pos = temp.find(\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        if port_pos == -1 or webserver_pos &lt; port_pos:\n            port = 80\n            webserver = temp[:webserver_pos]\n        else:\n            port = int(temp[(port_pos + 1) : webserver_pos])\n            webserver = temp[:port_pos]\n\n        # Connect to remote server\n        remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        remote_socket.connect((webserver, port))\n        remote_socket.send(request)\n\n        # Forward data between client and remote server\n        while True:\n            # Use proper type hints for select results\n            readable_sockets, _, _ = cast(\n                tuple[\n                    list[socket.socket], list[socket.socket], list[socket.socket]\n                ],\n                select.select([client_socket, remote_socket], [], [], 3),\n            )\n            if not readable_sockets:\n                break\n\n            for sock in readable_sockets:\n                other = remote_socket if sock is client_socket else client_socket\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                except OSError:\n                    return\n\n    except OSError as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if remote_socket:\n            remote_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                thread = threading.Thread(\n                    target=self.handle_client,\n                    args=(client_socket, client_address),\n                    daemon=True,\n                )\n                thread.start()\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre> Functions <code>run_http_proxy(host, port=8080)</code> <p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    with ProgressBar(title=\"Starting HTTP proxy...\") as pb:\n        for _ in pb(range(1)):\n            proxy = HTTPProxy(host, port)\n\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.http_proxy","title":"<code>http_proxy</code>","text":"<p>HTTP proxy server implementation.</p> Classes <code>HTTPProxy</code> <p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _client_address: Client address tuple (unused)\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            http_pos = url.find(b\"http://\")\n            temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n            port = 80\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            while self.running:\n                data = proxy_socket.recv(4096)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize the HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _client_address)</code> <p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Client address tuple (unused)</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _client_address: Client address tuple (unused)\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        http_pos = url.find(b\"http://\")\n        temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n        port = 80\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        while self.running:\n            data = proxy_socket.recv(4096)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre> Functions <code>run_http_proxy(host, port=8080)</code> <p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    proxy = HTTPProxy(host, port)\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.http_server","title":"<code>http_server</code>","text":"<p>HTTP server implementation for proxy functionality.</p> Classes <code>HTTPServer</code> <p>HTTP server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>class HTTPServer:\n    \"\"\"HTTP server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize HTTP server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n        \"\"\"Handle client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _: Unused client address tuple\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(BUFFER_SIZE)\n            if not request:\n                return\n\n            # Parse first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            # Extract host and port\n            http_pos = url.find(HTTP_PREFIX)\n            temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            port = DEFAULT_HTTP_PORT\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            # Connect to destination\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            # Relay data\n            while True:\n                data = proxy_socket.recv(BUFFER_SIZE)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        except Exception as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError as e:\n                    console.print(f\"[yellow]Connection error: {e}\")\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP server...\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _)</code> <p>Handle client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_</code> <code>tuple[str, int]</code> <p>Unused client address tuple</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n    \"\"\"Handle client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _: Unused client address tuple\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(BUFFER_SIZE)\n        if not request:\n            return\n\n        # Parse first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        # Extract host and port\n        http_pos = url.find(HTTP_PREFIX)\n        temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        port = DEFAULT_HTTP_PORT\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        # Connect to destination\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        # Relay data\n        while True:\n            data = proxy_socket.recv(BUFFER_SIZE)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    except Exception as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError as e:\n                console.print(f\"[yellow]Connection error: {e}\")\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP server...\")\n    finally:\n        self.server_socket.close()\n</code></pre> Functions <code>run_http_server(host, port=8080)</code> <p>Run HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def run_http_server(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server = HTTPServer(host, port)\n    server.start()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.socks","title":"<code>socks</code>","text":"<p>SOCKS proxy server command interface.</p> <p>This module provides a high-level interface for: - Starting the SOCKS proxy server - Managing worker processes - Handling server lifecycle - Progress reporting - Error handling</p> <p>The module integrates with the core proxy implementation and provides a user-friendly way to start and manage the proxy server.</p> Example Functions <code>run_socks_proxy(host, port=9050, processes=None)</code> <p>Run multi-process SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/socks.py</code> <pre><code>def run_socks_proxy(host: str, port: int = 9050, processes: int | None = None) -&gt; None:\n    \"\"\"Run multi-process SOCKS proxy server.\"\"\"\n    if not processes:\n        processes = multiprocessing.cpu_count()\n\n    with ProgressBar(title=f\"Starting SOCKS proxy with {processes} processes...\") as pb:\n        for _ in pb(range(1)):\n            pass  # Preparation step\n\n    console.print(\n        f\"[green]SOCKS5 proxy server started on {host}:{port} \"\n        f\"with {processes} processes\"\n    )\n\n    try:\n        create_proxy_server(host, port, processes)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.cmd.socks--start-a-socks-proxy-with-default-settings","title":"Start a SOCKS proxy with default settings","text":"<p>run_socks_proxy(\"192.168.1.100\")</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core","title":"<code>core</code>","text":"<p>Core proxy server implementation.</p> <p>This package contains the core components of the SOCKS proxy server: - Protocol handlers (SOCKS5) - Network interface management - Multi-process server implementation - Statistics tracking - User interface components - Exception handling</p> <p>The core package provides all the fundamental functionality needed to run a SOCKS proxy server, while keeping the implementation details separate from the command-line interface.</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.exceptions","title":"<code>exceptions</code>","text":"<p>Custom exceptions for the proxy server.</p> <p>This module defines custom exceptions used throughout the proxy server implementation. These exceptions provide more specific error handling for: - DNS resolution failures - Proxy connection errors - Network interface issues</p> <p>The exceptions are designed to be caught and handled appropriately by the proxy server components, providing meaningful error messages to the user.</p> Example <p>try:     resolved_ip = resolve_dns(\"example.com\") except DNSResolutionError as e:     console.print(f\"[red]Failed to resolve domain: {e}\")</p> Classes <code>DNSResolutionError</code> <p>               Bases: <code>ProxyError</code></p> <p>Raised when DNS resolution fails.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class DNSResolutionError(ProxyError):\n    \"\"\"Raised when DNS resolution fails.\"\"\"\n</code></pre> <code>ProxyError</code> <p>               Bases: <code>Exception</code></p> <p>Base exception for proxy errors.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class ProxyError(Exception):\n    \"\"\"Base exception for proxy errors.\"\"\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib","title":"<code>lib</code>","text":"<p>Core proxy library components.</p> Classes <code>SocksHandler</code> <p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre> Functions <code>forward(local, remote)</code> <p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre> <code>handle()</code> <p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre> <code>SocksProxy</code> <p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre> Functions <code>server_bind()</code> <p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre> Functions <code>create_proxy_server(host, port, num_processes)</code> <p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre> <code>run_server(host, port)</code> <p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre> Modules <code>dns_handler</code> <p>DNS resolution using dnspython.</p> Classes <code>DNSResolver</code> <p>Simple DNS resolver using dnspython.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>class DNSResolver:\n    \"\"\"Simple DNS resolver using dnspython.\"\"\"\n\n    # Class-level cache to avoid memory leaks\n    _resolve_cache: ClassVar[dict[str, str]] = {}\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n        self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n        self.resolver.timeout = DEFAULT_TIMEOUT\n        self.resolver.lifetime = DEFAULT_LIFETIME\n        self.resolver.nameservers = DEFAULT_NAMESERVERS\n\n    def resolve(self, domain: str) -&gt; str:\n        \"\"\"Resolve domain name to IP address.\n\n        Args:\n            domain: Domain name to resolve\n\n        Returns:\n            str: Resolved IP address\n\n        Raises:\n            DNSResolutionError: If resolution fails\n        \"\"\"\n        if domain in self._resolve_cache:\n            return self._resolve_cache[domain]\n\n        try:\n            # Try system DNS first (fastest when it works)\n            ip = socket.gethostbyname(domain)\n            self._resolve_cache[domain] = ip\n            return ip\n        except socket.gaierror:\n            try:\n                # Fallback to our configured resolver\n                answer = self.resolver.resolve(domain, \"A\")\n                ip = str(\n                    answer[0]\n                )  # DNS record objects have proper string representation\n                self._resolve_cache[domain] = ip\n                return ip\n            except Exception as dns_error:\n                error_msg = f\"Failed to resolve {domain}\"\n                raise DNSResolutionError(error_msg) from dns_error\n</code></pre> Functions <code>__init__()</code> <p>Initialize the DNS resolver with default settings.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n    self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n    self.resolver.timeout = DEFAULT_TIMEOUT\n    self.resolver.lifetime = DEFAULT_LIFETIME\n    self.resolver.nameservers = DEFAULT_NAMESERVERS\n</code></pre> <code>resolve(domain)</code> <p>Resolve domain name to IP address.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name to resolve</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resolved IP address</p> <p>Raises:</p> Type Description <code>DNSResolutionError</code> <p>If resolution fails</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def resolve(self, domain: str) -&gt; str:\n    \"\"\"Resolve domain name to IP address.\n\n    Args:\n        domain: Domain name to resolve\n\n    Returns:\n        str: Resolved IP address\n\n    Raises:\n        DNSResolutionError: If resolution fails\n    \"\"\"\n    if domain in self._resolve_cache:\n        return self._resolve_cache[domain]\n\n    try:\n        # Try system DNS first (fastest when it works)\n        ip = socket.gethostbyname(domain)\n        self._resolve_cache[domain] = ip\n        return ip\n    except socket.gaierror:\n        try:\n            # Fallback to our configured resolver\n            answer = self.resolver.resolve(domain, \"A\")\n            ip = str(\n                answer[0]\n            )  # DNS record objects have proper string representation\n            self._resolve_cache[domain] = ip\n            return ip\n        except Exception as dns_error:\n            error_msg = f\"Failed to resolve {domain}\"\n            raise DNSResolutionError(error_msg) from dns_error\n</code></pre> <code>proxy_server</code> <p>SOCKS proxy server implementation with multi-process support.</p> <p>This module implements a multi-process SOCKS proxy server with the following features: - Process pool management for handling multiple connections - Automatic process recovery on failure - WiFi interface detection and validation - Clean shutdown handling - UI integration - Clipboard integration for easy sharing</p> <p>The server supports: - Multiple simultaneous connections - Process-level parallelism - Automatic port reuse - Privilege checking - Interface validation</p> Example Classes <code>SocksProxy</code> <p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre> Functions <code>server_bind()</code> <p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre> Functions <code>create_proxy_server(host, port, num_processes)</code> <p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre> <code>is_wifi_interface(ip)</code> <p>Verify if the IP belongs to the WiFi interface.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def is_wifi_interface(ip: str) -&gt; bool:\n    \"\"\"Verify if the IP belongs to the WiFi interface.\"\"\"\n    for interface, addrs in psutil.net_if_addrs().items():\n        if interface.startswith((\"en\", \"wlan\", \"wifi\", \"eth\")):\n            for addr in addrs:\n                if addr.family == socket.AF_INET and addr.address == ip:\n                    return True\n    return False\n</code></pre> <code>run_server(host, port)</code> <p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre> <code>proxy_stats</code> <p>Statistics tracking and monitoring for the SOCKS proxy server.</p> <p>This module provides real-time statistics tracking for the proxy server, including: - Active connection counting - Bandwidth monitoring - Data transfer tracking - Historical bandwidth data</p> <p>The module uses thread-safe operations to track: - Number of active connections - Total bytes sent/received - Bandwidth usage over time - Server uptime</p> <p>The statistics are maintained in a thread-safe manner using locks and are designed to be accessed from multiple processes and threads without race conditions.</p> Example <code>socks_handler</code> <p>SOCKS protocol handler implementation for the proxy server.</p> <p>This module implements the SOCKS5 protocol according to RFC 1928, providing: - Protocol negotiation and handshaking - Authentication methods (currently no-auth) - Address type handling (IPv4 and domain names) - DNS resolution with fallback mechanisms - Bi-directional data forwarding - Connection tracking - Error handling and reporting</p> <p>The handler supports: - CONNECT method - IPv4 addresses - Domain name resolution - Configurable DNS resolvers - Connection statistics tracking - Timeout handling</p> Example Classes <code>SocksHandler</code> <p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre> Functions <code>forward(local, remote)</code> <p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre> <code>handle()</code> <p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib.proxy_server--create-and-start-a-proxy-server-with-4-processes","title":"Create and start a proxy server with 4 processes","text":"<p>create_proxy_server(\"192.168.1.100\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib.proxy_stats--global-stats-object-is-automatically-created","title":"Global stats object is automatically created","text":"<p>from .proxy_stats import proxy_stats</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib.proxy_stats--track-new-connection","title":"Track new connection","text":"<p>proxy_stats.connection_started()</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib.proxy_stats--update-transfer-statistics","title":"Update transfer statistics","text":"<p>proxy_stats.update_bytes(sent=1024, received=2048)</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.lib.socks_handler--the-handler-is-automatically-used-by-the-socksproxy-server-class","title":"The handler is automatically used by the SocksProxy server class","text":"<p>server = SocksProxy((host, port), SocksHandler) server.serve_forever()</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.network","title":"<code>network</code>","text":"<p>Network interface detection and management.</p> <p>This module provides functionality for: - Scanning available network interfaces - Detecting wireless interfaces - Validating interface status - IP address management - Interface filtering</p> <p>The module prioritizes wireless interfaces and provides detailed information about each interface including: - IP address - Interface status - Wireless capability - Interface name</p> Example <p>interface = scan_interfaces() if interface and interface.is_wireless:     print(f\"Found wireless interface {interface.name} with IP {interface.ip}\")</p> Classes <code>NetworkInterface</code> <code>dataclass</code> <p>Network interface representation with its key properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Interface name (e.g., 'en0', 'eth0')</p> <code>ip</code> <code>str</code> <p>IPv4 address assigned to the interface</p> <code>is_up</code> <code>bool</code> <p>Boolean indicating if the interface is up and running</p> <code>is_wireless</code> <code>bool</code> <p>Boolean indicating if this is a wireless interface</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>@dataclass\nclass NetworkInterface:\n    \"\"\"Network interface representation with its key properties.\n\n    Attributes:\n        name: Interface name (e.g., 'en0', 'eth0')\n        ip: IPv4 address assigned to the interface\n        is_up: Boolean indicating if the interface is up and running\n        is_wireless: Boolean indicating if this is a wireless interface\n    \"\"\"\n\n    name: str\n    ip: str\n    is_up: bool\n    is_wireless: bool\n</code></pre> Functions <code>scan_interfaces()</code> <p>Scan for available network interfaces and return the most suitable one.</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>def scan_interfaces() -&gt; NetworkInterface | None:\n    \"\"\"Scan for available network interfaces and return the most suitable one.\"\"\"\n    with Progress() as progress:\n        task = progress.add_task(\"Scanning network interfaces...\", total=1)\n\n        # Get all network interfaces\n        interfaces = []\n        for name, addrs in psutil.net_if_addrs().items():\n            # Skip loopback and virtual interfaces\n            if name.startswith(\n                (\n                    \"lo\",\n                    \"vmnet\",\n                    \"docker\",\n                    \"veth\",\n                    \"bridge\",\n                    \"utun\",\n                    \"llw\",\n                    \"awdl\",\n                    \"anpi\",\n                    \"stf\",\n                    \"gif\",\n                    \"ap\",\n                )\n            ):\n                continue\n\n            # Get IPv4 address\n            ipv4 = next(\n                (addr.address for addr in addrs if addr.family == socket.AF_INET), None\n            )\n            if not ipv4:\n                continue\n\n            # Check if interface is up\n            stats = psutil.net_if_stats().get(name)\n            if not stats or not stats.isup:\n                continue\n\n            # Get interface status\n            try:\n                import shutil\n                import subprocess\n\n                ifconfig_path = shutil.which(\"ifconfig\")\n                if not ifconfig_path:\n                    console.log(\"ifconfig not found\")\n                    continue\n\n                result = subprocess.run(\n                    [ifconfig_path, name], capture_output=True, text=True, check=False\n                )\n                is_active = \"status: active\" in result.stdout\n                if not is_active:\n                    continue\n            except Exception as e:\n                console.log(f\"Error checking interface {name}: {e!s}\")\n                continue\n\n            # Determine if it's a wireless interface (macOS specific)\n            is_wireless = name == \"en0\"  # On macOS, en0 is typically the built-in WiFi\n\n            interfaces.append(\n                NetworkInterface(\n                    name=name, ip=ipv4, is_up=True, is_wireless=is_wireless\n                )\n            )\n\n        progress.update(task, advance=1)\n\n        # First try to find en0 (WiFi on macOS)\n        wifi = next((iface for iface in interfaces if iface.name == \"en0\"), None)\n        if wifi:\n            return wifi\n\n        # Then try other wireless interfaces\n        wireless = [iface for iface in interfaces if iface.is_wireless]\n        if wireless:\n            return wireless[0]\n\n        # Finally, fall back to any available interface\n        if interfaces:\n            return interfaces[0]\n\n        return None\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.proxy","title":"<code>proxy</code>","text":"<p>Core proxy functionality and main entry point for the SOCKS proxy server.</p> <p>This module serves as the main entry point for the SOCKS proxy server functionality. It provides a clean interface to the underlying proxy implementation by exposing only the necessary components through its public API.</p> <p>The module abstracts away the complexity of: - Multi-process SOCKS server management - User interface handling - Statistics tracking - Connection management</p> Example <p>from hotspot_socks_proxy.core.proxy import create_proxy_server</p> <p>Attributes:</p> Name Type Description <code>__all__</code> <code>list</code> <p>List of public components exposed by this module</p> Functions <code>create_proxy_server(host, port, num_processes)</code> <p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.proxy--start-a-socks-proxy-server-on-localhost9050-with-4-processes","title":"Start a SOCKS proxy server on localhost:9050 with 4 processes","text":"<p>create_proxy_server(\"127.0.0.1\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/#hotspot_socks_proxy.core.utils","title":"<code>utils</code>","text":"<p>Utility functions and helpers.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre> <code>format_bytes(bytes_)</code> <p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre> Modules <code>prompt</code> <p>Prompt and UI utilities.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre> <code>ProxyUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre> <code>SocksUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre> Modules <code>prompt</code> <p>Base prompt handling and UI components.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre> <code>proxy_ui</code> <p>Proxy-specific UI components.</p> Classes <code>ProxyUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre> <code>socks_ui</code> <p>SOCKS-specific UI components.</p> Classes <code>SocksUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre> <code>utils</code> <p>Common utility functions.</p> Functions <code>format_bytes(bytes_)</code> <p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/","title":"hotspot_socks_proxy.cmd","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd","title":"<code>hotspot_socks_proxy.cmd</code>","text":"<p>Command line interface modules.</p> <p>This package provides the command-line tools and utilities for: - Starting and managing proxy servers - Finding and configuring network interfaces - Displaying server statistics - Managing server processes - Error reporting and logging</p> <p>The command modules provide user-friendly interfaces to the core proxy server functionality, making it easy to start and manage proxy servers from the command line.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli","title":"<code>cli</code>","text":"<p>Command-line interface for the SOCKS proxy server.</p> <p>This module provides the main command-line interface for the proxy server, handling: - Command-line argument parsing - Server initialization - Process management - Root privilege checking - Error reporting - Interface selection</p> <p>The CLI is built using Typer and provides a user-friendly interface for: - Starting the proxy server - Configuring the number of worker processes - Setting the listening port - Managing server lifecycle</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli--run-from-command-line","title":"Run from command line:","text":"<p>$ python -m hotspot_socks_proxy proxy --port 9050 --processes 4</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli.check_root","title":"<code>check_root()</code>","text":"<p>Check if the script is running with root privileges.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>def check_root() -&gt; bool:\n    \"\"\"Check if the script is running with root privileges.\"\"\"\n    if os.name == \"nt\":  # Windows\n        try:\n            import ctypes\n\n            return ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception:\n            return False\n    else:  # Unix-like\n        return os.geteuid() == 0\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli.start_proxy","title":"<code>start_proxy(processes=typer.Option(None, '--processes', '-p', help='Number of CPU processes (default: CPU count)'), port=typer.Option(9050, '--port', help='Port to listen on'))</code>","text":"<p>Start the SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.command(name=\"proxy\")\ndef start_proxy(\n    processes: int | None = typer.Option(\n        None, \"--processes\", \"-p\", help=\"Number of CPU processes (default: CPU count)\"\n    ),\n    port: int = typer.Option(9050, \"--port\", help=\"Port to listen on\"),\n):\n    \"\"\"Start the SOCKS proxy server.\"\"\"\n    if not check_root():\n        console.print(\"[red]This program requires root privileges to run properly.\")\n        console.print(\"[yellow]Please run with sudo or as root.\")\n        sys.exit(1)\n\n    # Get available interfaces\n    interface = scan_interfaces()\n    if not interface:\n        console.print(\"[red]No suitable network interface found\")\n        return\n\n    try:\n        # Convert None to CPU count before passing to create_proxy_server\n        process_count = processes if processes is not None else os.cpu_count() or 1\n        create_proxy_server(interface.ip, port, process_count)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.cli.version_callback","title":"<code>version_callback()</code>","text":"<p>Show version information.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef version_callback():\n    \"\"\"Show version information.\"\"\"\n    console.print(f\"[cyan]Hotspot SOCKS Proxy v{__version__}[/cyan]\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.find_wifi","title":"<code>find_wifi</code>","text":"<p>WiFi interface detection and information display.</p> <p>This module provides functionality for: - Detecting WiFi interfaces - Gathering interface information - Displaying interface details - MAC address lookup - Status checking</p> <p>The module uses system commands to gather detailed information about WiFi interfaces and presents it in a formatted table using Rich.</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.find_wifi--show-information-about-the-wifi-interface","title":"Show information about the WiFi interface","text":"<p>show_wifi_info()</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.find_wifi-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.find_wifi.get_interface_info","title":"<code>get_interface_info()</code>","text":"<p>Get information about the network interface.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def get_interface_info() -&gt; dict[str, str]:\n    \"\"\"Get information about the network interface.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    result = subprocess.run(\n        [str(Path(\"/sbin/ifconfig\")), \"en0\"],\n        capture_output=True,\n        text=True,\n        check=False,\n    )\n    if result.returncode != 0:\n        return {\"ip\": \"Not found\", \"mac\": \"Not found\", \"status\": \"Error\"}\n\n    output = result.stdout\n\n    # Parse interface information\n    ip_match = re.search(r\"inet (\\d+\\.\\d+\\.\\d+\\.\\d+)\", output)\n    mac_match = re.search(r\"ether (\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w)\", output)\n    status_match = re.search(r\"status: (\\w+)\", output)\n\n    return {\n        \"ip\": ip_match.group(1) if ip_match else \"Not found\",\n        \"mac\": mac_match.group(1) if mac_match else \"Not found\",\n        \"status\": status_match.group(1) if status_match else \"Unknown\",\n    }\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.find_wifi.show_wifi_info","title":"<code>show_wifi_info()</code>","text":"<p>Display WiFi interface information and return the interface details.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def show_wifi_info() -&gt; dict[str, str]:\n    \"\"\"Display WiFi interface information and return the interface details.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    info = get_interface_info()\n\n    table = Table(title=\"WiFi Interface (en0) Information\")\n    table.add_column(\"Property\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n\n    table.add_row(\"IP Address\", info[\"ip\"])\n    table.add_row(\"MAC Address\", info[\"mac\"])\n    table.add_row(\"Status\", info[\"status\"])\n\n    console.print(table)\n    return info\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_handler","title":"<code>http_handler</code>","text":"<p>HTTP handler implementation.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy","title":"<code>HTTPProxy</code>","text":"<p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: The connected client socket\n            _client_address: Tuple of (host, port) representing client address\n        \"\"\"\n        remote_socket = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n            url = first_line.split(\" \")[1]\n\n            # Extract hostname and port\n            http_pos = url.find(\"://\")\n            temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n            port_pos = temp.find(\":\")\n            webserver_pos = temp.find(\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            if port_pos == -1 or webserver_pos &lt; port_pos:\n                port = 80\n                webserver = temp[:webserver_pos]\n            else:\n                port = int(temp[(port_pos + 1) : webserver_pos])\n                webserver = temp[:port_pos]\n\n            # Connect to remote server\n            remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            remote_socket.connect((webserver, port))\n            remote_socket.send(request)\n\n            # Forward data between client and remote server\n            while True:\n                # Use proper type hints for select results\n                readable_sockets, _, _ = cast(\n                    tuple[\n                        list[socket.socket], list[socket.socket], list[socket.socket]\n                    ],\n                    select.select([client_socket, remote_socket], [], [], 3),\n                )\n                if not readable_sockets:\n                    break\n\n                for sock in readable_sockets:\n                    other = remote_socket if sock is client_socket else client_socket\n                    try:\n                        data = sock.recv(4096)\n                        if not data:\n                            return\n                        other.send(data)\n                    except OSError:\n                        return\n\n        except OSError as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if remote_socket:\n                remote_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    thread = threading.Thread(\n                        target=self.handle_client,\n                        args=(client_socket, client_address),\n                        daemon=True,\n                    )\n                    thread.start()\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _client_address)</code> <p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>The connected client socket</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Tuple of (host, port) representing client address</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: The connected client socket\n        _client_address: Tuple of (host, port) representing client address\n    \"\"\"\n    remote_socket = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n        url = first_line.split(\" \")[1]\n\n        # Extract hostname and port\n        http_pos = url.find(\"://\")\n        temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n        port_pos = temp.find(\":\")\n        webserver_pos = temp.find(\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        if port_pos == -1 or webserver_pos &lt; port_pos:\n            port = 80\n            webserver = temp[:webserver_pos]\n        else:\n            port = int(temp[(port_pos + 1) : webserver_pos])\n            webserver = temp[:port_pos]\n\n        # Connect to remote server\n        remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        remote_socket.connect((webserver, port))\n        remote_socket.send(request)\n\n        # Forward data between client and remote server\n        while True:\n            # Use proper type hints for select results\n            readable_sockets, _, _ = cast(\n                tuple[\n                    list[socket.socket], list[socket.socket], list[socket.socket]\n                ],\n                select.select([client_socket, remote_socket], [], [], 3),\n            )\n            if not readable_sockets:\n                break\n\n            for sock in readable_sockets:\n                other = remote_socket if sock is client_socket else client_socket\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                except OSError:\n                    return\n\n    except OSError as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if remote_socket:\n            remote_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                thread = threading.Thread(\n                    target=self.handle_client,\n                    args=(client_socket, client_address),\n                    daemon=True,\n                )\n                thread.start()\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_handler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_handler.run_http_proxy","title":"<code>run_http_proxy(host, port=8080)</code>","text":"<p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    with ProgressBar(title=\"Starting HTTP proxy...\") as pb:\n        for _ in pb(range(1)):\n            proxy = HTTPProxy(host, port)\n\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_proxy","title":"<code>http_proxy</code>","text":"<p>HTTP proxy server implementation.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_proxy-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy","title":"<code>HTTPProxy</code>","text":"<p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _client_address: Client address tuple (unused)\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            http_pos = url.find(b\"http://\")\n            temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n            port = 80\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            while self.running:\n                data = proxy_socket.recv(4096)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize the HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _client_address)</code> <p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Client address tuple (unused)</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _client_address: Client address tuple (unused)\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        http_pos = url.find(b\"http://\")\n        temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n        port = 80\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        while self.running:\n            data = proxy_socket.recv(4096)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_proxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_proxy.run_http_proxy","title":"<code>run_http_proxy(host, port=8080)</code>","text":"<p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    proxy = HTTPProxy(host, port)\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_server","title":"<code>http_server</code>","text":"<p>HTTP server implementation for proxy functionality.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_server-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_server.HTTPServer","title":"<code>HTTPServer</code>","text":"<p>HTTP server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>class HTTPServer:\n    \"\"\"HTTP server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize HTTP server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n        \"\"\"Handle client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _: Unused client address tuple\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(BUFFER_SIZE)\n            if not request:\n                return\n\n            # Parse first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            # Extract host and port\n            http_pos = url.find(HTTP_PREFIX)\n            temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            port = DEFAULT_HTTP_PORT\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            # Connect to destination\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            # Relay data\n            while True:\n                data = proxy_socket.recv(BUFFER_SIZE)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        except Exception as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError as e:\n                    console.print(f\"[yellow]Connection error: {e}\")\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP server...\")\n        finally:\n            self.server_socket.close()\n</code></pre> Functions <code>__init__(host, port)</code> <p>Initialize HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre> <code>handle_client(client_socket, _)</code> <p>Handle client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_</code> <code>tuple[str, int]</code> <p>Unused client address tuple</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n    \"\"\"Handle client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _: Unused client address tuple\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(BUFFER_SIZE)\n        if not request:\n            return\n\n        # Parse first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        # Extract host and port\n        http_pos = url.find(HTTP_PREFIX)\n        temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        port = DEFAULT_HTTP_PORT\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        # Connect to destination\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        # Relay data\n        while True:\n            data = proxy_socket.recv(BUFFER_SIZE)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    except Exception as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre> <code>start()</code> <p>Start the HTTP server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError as e:\n                console.print(f\"[yellow]Connection error: {e}\")\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP server...\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_server-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.http_server.run_http_server","title":"<code>run_http_server(host, port=8080)</code>","text":"<p>Run HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def run_http_server(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server = HTTPServer(host, port)\n    server.start()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.socks","title":"<code>socks</code>","text":"<p>SOCKS proxy server command interface.</p> <p>This module provides a high-level interface for: - Starting the SOCKS proxy server - Managing worker processes - Handling server lifecycle - Progress reporting - Error handling</p> <p>The module integrates with the core proxy implementation and provides a user-friendly way to start and manage the proxy server.</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.socks--start-a-socks-proxy-with-default-settings","title":"Start a SOCKS proxy with default settings","text":"<p>run_socks_proxy(\"192.168.1.100\")</p>"},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.socks-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/#hotspot_socks_proxy.cmd.socks.run_socks_proxy","title":"<code>run_socks_proxy(host, port=9050, processes=None)</code>","text":"<p>Run multi-process SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/socks.py</code> <pre><code>def run_socks_proxy(host: str, port: int = 9050, processes: int | None = None) -&gt; None:\n    \"\"\"Run multi-process SOCKS proxy server.\"\"\"\n    if not processes:\n        processes = multiprocessing.cpu_count()\n\n    with ProgressBar(title=f\"Starting SOCKS proxy with {processes} processes...\") as pb:\n        for _ in pb(range(1)):\n            pass  # Preparation step\n\n    console.print(\n        f\"[green]SOCKS5 proxy server started on {host}:{port} \"\n        f\"with {processes} processes\"\n    )\n\n    try:\n        create_proxy_server(host, port, processes)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/cli/","title":"hotspot_socks_proxy.cmd.cli","text":""},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli","title":"<code>hotspot_socks_proxy.cmd.cli</code>","text":"<p>Command-line interface for the SOCKS proxy server.</p> <p>This module provides the main command-line interface for the proxy server, handling: - Command-line argument parsing - Server initialization - Process management - Root privilege checking - Error reporting - Interface selection</p> <p>The CLI is built using Typer and provides a user-friendly interface for: - Starting the proxy server - Configuring the number of worker processes - Setting the listening port - Managing server lifecycle</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli--run-from-command-line","title":"Run from command line:","text":"<p>$ python -m hotspot_socks_proxy proxy --port 9050 --processes 4</p>"},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli.check_root","title":"<code>check_root()</code>","text":"<p>Check if the script is running with root privileges.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>def check_root() -&gt; bool:\n    \"\"\"Check if the script is running with root privileges.\"\"\"\n    if os.name == \"nt\":  # Windows\n        try:\n            import ctypes\n\n            return ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception:\n            return False\n    else:  # Unix-like\n        return os.geteuid() == 0\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli.start_proxy","title":"<code>start_proxy(processes=typer.Option(None, '--processes', '-p', help='Number of CPU processes (default: CPU count)'), port=typer.Option(9050, '--port', help='Port to listen on'))</code>","text":"<p>Start the SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.command(name=\"proxy\")\ndef start_proxy(\n    processes: int | None = typer.Option(\n        None, \"--processes\", \"-p\", help=\"Number of CPU processes (default: CPU count)\"\n    ),\n    port: int = typer.Option(9050, \"--port\", help=\"Port to listen on\"),\n):\n    \"\"\"Start the SOCKS proxy server.\"\"\"\n    if not check_root():\n        console.print(\"[red]This program requires root privileges to run properly.\")\n        console.print(\"[yellow]Please run with sudo or as root.\")\n        sys.exit(1)\n\n    # Get available interfaces\n    interface = scan_interfaces()\n    if not interface:\n        console.print(\"[red]No suitable network interface found\")\n        return\n\n    try:\n        # Convert None to CPU count before passing to create_proxy_server\n        process_count = processes if processes is not None else os.cpu_count() or 1\n        create_proxy_server(interface.ip, port, process_count)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/cli/#hotspot_socks_proxy.cmd.cli.version_callback","title":"<code>version_callback()</code>","text":"<p>Show version information.</p> Source code in <code>src/hotspot_socks_proxy/cmd/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef version_callback():\n    \"\"\"Show version information.\"\"\"\n    console.print(f\"[cyan]Hotspot SOCKS Proxy v{__version__}[/cyan]\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/","title":"hotspot_socks_proxy.cmd.find_wifi","text":""},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/#hotspot_socks_proxy.cmd.find_wifi","title":"<code>hotspot_socks_proxy.cmd.find_wifi</code>","text":"<p>WiFi interface detection and information display.</p> <p>This module provides functionality for: - Detecting WiFi interfaces - Gathering interface information - Displaying interface details - MAC address lookup - Status checking</p> <p>The module uses system commands to gather detailed information about WiFi interfaces and presents it in a formatted table using Rich.</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/#hotspot_socks_proxy.cmd.find_wifi--show-information-about-the-wifi-interface","title":"Show information about the WiFi interface","text":"<p>show_wifi_info()</p>"},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/#hotspot_socks_proxy.cmd.find_wifi-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/#hotspot_socks_proxy.cmd.find_wifi.get_interface_info","title":"<code>get_interface_info()</code>","text":"<p>Get information about the network interface.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def get_interface_info() -&gt; dict[str, str]:\n    \"\"\"Get information about the network interface.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    result = subprocess.run(\n        [str(Path(\"/sbin/ifconfig\")), \"en0\"],\n        capture_output=True,\n        text=True,\n        check=False,\n    )\n    if result.returncode != 0:\n        return {\"ip\": \"Not found\", \"mac\": \"Not found\", \"status\": \"Error\"}\n\n    output = result.stdout\n\n    # Parse interface information\n    ip_match = re.search(r\"inet (\\d+\\.\\d+\\.\\d+\\.\\d+)\", output)\n    mac_match = re.search(r\"ether (\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w:\\w\\w)\", output)\n    status_match = re.search(r\"status: (\\w+)\", output)\n\n    return {\n        \"ip\": ip_match.group(1) if ip_match else \"Not found\",\n        \"mac\": mac_match.group(1) if mac_match else \"Not found\",\n        \"status\": status_match.group(1) if status_match else \"Unknown\",\n    }\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/find_wifi/#hotspot_socks_proxy.cmd.find_wifi.show_wifi_info","title":"<code>show_wifi_info()</code>","text":"<p>Display WiFi interface information and return the interface details.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary containing interface information with keys: - ip: IP address - mac: MAC address - status: Interface status</p> Source code in <code>src/hotspot_socks_proxy/cmd/find_wifi.py</code> <pre><code>def show_wifi_info() -&gt; dict[str, str]:\n    \"\"\"Display WiFi interface information and return the interface details.\n\n    Returns:\n        dict[str, str]: Dictionary containing interface information with keys:\n            - ip: IP address\n            - mac: MAC address\n            - status: Interface status\n    \"\"\"\n    info = get_interface_info()\n\n    table = Table(title=\"WiFi Interface (en0) Information\")\n    table.add_column(\"Property\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n\n    table.add_row(\"IP Address\", info[\"ip\"])\n    table.add_row(\"MAC Address\", info[\"mac\"])\n    table.add_row(\"Status\", info[\"status\"])\n\n    console.print(table)\n    return info\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/","title":"hotspot_socks_proxy.cmd.http_handler","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler","title":"<code>hotspot_socks_proxy.cmd.http_handler</code>","text":"<p>HTTP handler implementation.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy","title":"<code>HTTPProxy</code>","text":"<p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: The connected client socket\n            _client_address: Tuple of (host, port) representing client address\n        \"\"\"\n        remote_socket = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n            url = first_line.split(\" \")[1]\n\n            # Extract hostname and port\n            http_pos = url.find(\"://\")\n            temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n            port_pos = temp.find(\":\")\n            webserver_pos = temp.find(\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            if port_pos == -1 or webserver_pos &lt; port_pos:\n                port = 80\n                webserver = temp[:webserver_pos]\n            else:\n                port = int(temp[(port_pos + 1) : webserver_pos])\n                webserver = temp[:port_pos]\n\n            # Connect to remote server\n            remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            remote_socket.connect((webserver, port))\n            remote_socket.send(request)\n\n            # Forward data between client and remote server\n            while True:\n                # Use proper type hints for select results\n                readable_sockets, _, _ = cast(\n                    tuple[\n                        list[socket.socket], list[socket.socket], list[socket.socket]\n                    ],\n                    select.select([client_socket, remote_socket], [], [], 3),\n                )\n                if not readable_sockets:\n                    break\n\n                for sock in readable_sockets:\n                    other = remote_socket if sock is client_socket else client_socket\n                    try:\n                        data = sock.recv(4096)\n                        if not data:\n                            return\n                        other.send(data)\n                    except OSError:\n                        return\n\n        except OSError as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if remote_socket:\n                remote_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    thread = threading.Thread(\n                        target=self.handle_client,\n                        args=(client_socket, client_address),\n                        daemon=True,\n                    )\n                    thread.start()\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy.__init__","title":"<code>__init__(host, port)</code>","text":"<p>Initialize the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy.handle_client","title":"<code>handle_client(client_socket, _client_address)</code>","text":"<p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>The connected client socket</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Tuple of (host, port) representing client address</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: The connected client socket\n        _client_address: Tuple of (host, port) representing client address\n    \"\"\"\n    remote_socket = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0].decode(\"utf-8\")\n        url = first_line.split(\" \")[1]\n\n        # Extract hostname and port\n        http_pos = url.find(\"://\")\n        temp = url if http_pos == -1 else url[(http_pos + 3) :]\n\n        port_pos = temp.find(\":\")\n        webserver_pos = temp.find(\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        if port_pos == -1 or webserver_pos &lt; port_pos:\n            port = 80\n            webserver = temp[:webserver_pos]\n        else:\n            port = int(temp[(port_pos + 1) : webserver_pos])\n            webserver = temp[:port_pos]\n\n        # Connect to remote server\n        remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        remote_socket.connect((webserver, port))\n        remote_socket.send(request)\n\n        # Forward data between client and remote server\n        while True:\n            # Use proper type hints for select results\n            readable_sockets, _, _ = cast(\n                tuple[\n                    list[socket.socket], list[socket.socket], list[socket.socket]\n                ],\n                select.select([client_socket, remote_socket], [], [], 3),\n            )\n            if not readable_sockets:\n                break\n\n            for sock in readable_sockets:\n                other = remote_socket if sock is client_socket else client_socket\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                except OSError:\n                    return\n\n    except OSError as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if remote_socket:\n            remote_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.HTTPProxy.start","title":"<code>start()</code>","text":"<p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                thread = threading.Thread(\n                    target=self.handle_client,\n                    args=(client_socket, client_address),\n                    daemon=True,\n                )\n                thread.start()\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_handler/#hotspot_socks_proxy.cmd.http_handler.run_http_proxy","title":"<code>run_http_proxy(host, port=8080)</code>","text":"<p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_handler.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    with ProgressBar(title=\"Starting HTTP proxy...\") as pb:\n        for _ in pb(range(1)):\n            proxy = HTTPProxy(host, port)\n\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/","title":"hotspot_socks_proxy.cmd.http_proxy","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy","title":"<code>hotspot_socks_proxy.cmd.http_proxy</code>","text":"<p>HTTP proxy server implementation.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy","title":"<code>HTTPProxy</code>","text":"<p>HTTP proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>class HTTPProxy:\n    \"\"\"HTTP proxy server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize the HTTP proxy server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(\n        self, client_socket: socket.socket, _client_address: tuple[str, int]\n    ) -&gt; None:\n        \"\"\"Handle an incoming client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _client_address: Client address tuple (unused)\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(4096)\n            if not request:\n                return\n\n            # Parse the first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            http_pos = url.find(b\"http://\")\n            temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n            port = 80\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            while self.running:\n                data = proxy_socket.recv(4096)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP proxy server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(\n                f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n            )\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError:\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n        except Exception as e:\n            console.print(f\"[red]Error starting proxy: {e}\")\n        finally:\n            self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy.__init__","title":"<code>__init__(host, port)</code>","text":"<p>Initialize the HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize the HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy.handle_client","title":"<code>handle_client(client_socket, _client_address)</code>","text":"<p>Handle an incoming client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_client_address</code> <code>tuple[str, int]</code> <p>Client address tuple (unused)</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def handle_client(\n    self, client_socket: socket.socket, _client_address: tuple[str, int]\n) -&gt; None:\n    \"\"\"Handle an incoming client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _client_address: Client address tuple (unused)\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(4096)\n        if not request:\n            return\n\n        # Parse the first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        http_pos = url.find(b\"http://\")\n        temp = url[http_pos + 7 :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n        port = 80\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        while self.running:\n            data = proxy_socket.recv(4096)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.HTTPProxy.start","title":"<code>start()</code>","text":"<p>Start the HTTP proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP proxy server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(\n            f\"[green]HTTP proxy server started on {self.host}:{self.port}\"\n        )\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError:\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP proxy server...\")\n    except Exception as e:\n        console.print(f\"[red]Error starting proxy: {e}\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_proxy/#hotspot_socks_proxy.cmd.http_proxy.run_http_proxy","title":"<code>run_http_proxy(host, port=8080)</code>","text":"<p>Run HTTP proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_proxy.py</code> <pre><code>def run_http_proxy(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    proxy = HTTPProxy(host, port)\n    try:\n        proxy.start()\n    except Exception as e:\n        console.print(f\"[red]Error running HTTP proxy: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/","title":"hotspot_socks_proxy.cmd.http_server","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server","title":"<code>hotspot_socks_proxy.cmd.http_server</code>","text":"<p>HTTP server implementation for proxy functionality.</p>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.HTTPServer","title":"<code>HTTPServer</code>","text":"<p>HTTP server implementation.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>class HTTPServer:\n    \"\"\"HTTP server implementation.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Initialize HTTP server.\n\n        Args:\n            host: Host address to bind to\n            port: Port number to listen on\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.running = True\n\n    def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n        \"\"\"Handle client connection.\n\n        Args:\n            client_socket: Client socket connection\n            _: Unused client address tuple\n        \"\"\"\n        proxy_socket: socket.socket | None = None\n        try:\n            request = client_socket.recv(BUFFER_SIZE)\n            if not request:\n                return\n\n            # Parse first line\n            first_line = request.split(b\"\\n\")[0]\n            url = first_line.split()[1]\n\n            # Extract host and port\n            http_pos = url.find(HTTP_PREFIX)\n            temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n            port_pos = temp.find(b\":\")\n            webserver_pos = temp.find(b\"/\")\n            if webserver_pos == -1:\n                webserver_pos = len(temp)\n\n            port = DEFAULT_HTTP_PORT\n            webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n            if port_pos != -1 and port_pos &lt; webserver_pos:\n                port = int(temp[port_pos + 1 : webserver_pos])\n                webserver = temp[:port_pos].decode(\"utf-8\")\n\n            # Connect to destination\n            proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            proxy_socket.connect((webserver, port))\n            proxy_socket.send(request)\n\n            # Relay data\n            while True:\n                data = proxy_socket.recv(BUFFER_SIZE)\n                if not data:\n                    break\n                client_socket.send(data)\n\n        except OSError as e:\n            console.print(f\"[red]Socket error: {e}\")\n        except Exception as e:\n            console.print(f\"[red]Error handling client: {e}\")\n        finally:\n            client_socket.close()\n            if proxy_socket:\n                proxy_socket.close()\n\n    def start(self) -&gt; None:\n        \"\"\"Start the HTTP server.\"\"\"\n        try:\n            self.server_socket.bind((self.host, self.port))\n            self.server_socket.listen(5)\n            console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n            while self.running:\n                try:\n                    client_socket, client_address = self.server_socket.accept()\n                    self.handle_client(client_socket, client_address)\n                except OSError as e:\n                    console.print(f\"[yellow]Connection error: {e}\")\n                    continue\n\n        except KeyboardInterrupt:\n            self.running = False\n            console.print(\"\\n[yellow]Shutting down HTTP server...\")\n        finally:\n            self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.HTTPServer-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.HTTPServer.__init__","title":"<code>__init__(host, port)</code>","text":"<p>Initialize HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.running = True\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.HTTPServer.handle_client","title":"<code>handle_client(client_socket, _)</code>","text":"<p>Handle client connection.</p> <p>Parameters:</p> Name Type Description Default <code>client_socket</code> <code>socket</code> <p>Client socket connection</p> required <code>_</code> <code>tuple[str, int]</code> <p>Unused client address tuple</p> required Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def handle_client(self, client_socket: socket.socket, _: tuple[str, int]) -&gt; None:\n    \"\"\"Handle client connection.\n\n    Args:\n        client_socket: Client socket connection\n        _: Unused client address tuple\n    \"\"\"\n    proxy_socket: socket.socket | None = None\n    try:\n        request = client_socket.recv(BUFFER_SIZE)\n        if not request:\n            return\n\n        # Parse first line\n        first_line = request.split(b\"\\n\")[0]\n        url = first_line.split()[1]\n\n        # Extract host and port\n        http_pos = url.find(HTTP_PREFIX)\n        temp = url[http_pos + len(HTTP_PREFIX) :] if http_pos != -1 else url\n\n        port_pos = temp.find(b\":\")\n        webserver_pos = temp.find(b\"/\")\n        if webserver_pos == -1:\n            webserver_pos = len(temp)\n\n        port = DEFAULT_HTTP_PORT\n        webserver = temp[:webserver_pos].decode(\"utf-8\")\n\n        if port_pos != -1 and port_pos &lt; webserver_pos:\n            port = int(temp[port_pos + 1 : webserver_pos])\n            webserver = temp[:port_pos].decode(\"utf-8\")\n\n        # Connect to destination\n        proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        proxy_socket.connect((webserver, port))\n        proxy_socket.send(request)\n\n        # Relay data\n        while True:\n            data = proxy_socket.recv(BUFFER_SIZE)\n            if not data:\n                break\n            client_socket.send(data)\n\n    except OSError as e:\n        console.print(f\"[red]Socket error: {e}\")\n    except Exception as e:\n        console.print(f\"[red]Error handling client: {e}\")\n    finally:\n        client_socket.close()\n        if proxy_socket:\n            proxy_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.HTTPServer.start","title":"<code>start()</code>","text":"<p>Start the HTTP server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the HTTP server.\"\"\"\n    try:\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        console.print(f\"[green]HTTP server listening on {self.host}:{self.port}\")\n\n        while self.running:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.handle_client(client_socket, client_address)\n            except OSError as e:\n                console.print(f\"[yellow]Connection error: {e}\")\n                continue\n\n    except KeyboardInterrupt:\n        self.running = False\n        console.print(\"\\n[yellow]Shutting down HTTP server...\")\n    finally:\n        self.server_socket.close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/http_server/#hotspot_socks_proxy.cmd.http_server.run_http_server","title":"<code>run_http_server(host, port=8080)</code>","text":"<p>Run HTTP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> <code>8080</code> Source code in <code>src/hotspot_socks_proxy/cmd/http_server.py</code> <pre><code>def run_http_server(host: str, port: int = 8080) -&gt; None:\n    \"\"\"Run HTTP server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server = HTTPServer(host, port)\n    server.start()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/cmd/socks/","title":"hotspot_socks_proxy.cmd.socks","text":""},{"location":"reference/hotspot_socks_proxy/cmd/socks/#hotspot_socks_proxy.cmd.socks","title":"<code>hotspot_socks_proxy.cmd.socks</code>","text":"<p>SOCKS proxy server command interface.</p> <p>This module provides a high-level interface for: - Starting the SOCKS proxy server - Managing worker processes - Handling server lifecycle - Progress reporting - Error handling</p> <p>The module integrates with the core proxy implementation and provides a user-friendly way to start and manage the proxy server.</p> Example"},{"location":"reference/hotspot_socks_proxy/cmd/socks/#hotspot_socks_proxy.cmd.socks--start-a-socks-proxy-with-default-settings","title":"Start a SOCKS proxy with default settings","text":"<p>run_socks_proxy(\"192.168.1.100\")</p>"},{"location":"reference/hotspot_socks_proxy/cmd/socks/#hotspot_socks_proxy.cmd.socks-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/cmd/socks/#hotspot_socks_proxy.cmd.socks.run_socks_proxy","title":"<code>run_socks_proxy(host, port=9050, processes=None)</code>","text":"<p>Run multi-process SOCKS proxy server.</p> Source code in <code>src/hotspot_socks_proxy/cmd/socks.py</code> <pre><code>def run_socks_proxy(host: str, port: int = 9050, processes: int | None = None) -&gt; None:\n    \"\"\"Run multi-process SOCKS proxy server.\"\"\"\n    if not processes:\n        processes = multiprocessing.cpu_count()\n\n    with ProgressBar(title=f\"Starting SOCKS proxy with {processes} processes...\") as pb:\n        for _ in pb(range(1)):\n            pass  # Preparation step\n\n    console.print(\n        f\"[green]SOCKS5 proxy server started on {host}:{port} \"\n        f\"with {processes} processes\"\n    )\n\n    try:\n        create_proxy_server(host, port, processes)\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/","title":"hotspot_socks_proxy.core","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core","title":"<code>hotspot_socks_proxy.core</code>","text":"<p>Core proxy server implementation.</p> <p>This package contains the core components of the SOCKS proxy server: - Protocol handlers (SOCKS5) - Network interface management - Multi-process server implementation - Statistics tracking - User interface components - Exception handling</p> <p>The core package provides all the fundamental functionality needed to run a SOCKS proxy server, while keeping the implementation details separate from the command-line interface.</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.exceptions","title":"<code>exceptions</code>","text":"<p>Custom exceptions for the proxy server.</p> <p>This module defines custom exceptions used throughout the proxy server implementation. These exceptions provide more specific error handling for: - DNS resolution failures - Proxy connection errors - Network interface issues</p> <p>The exceptions are designed to be caught and handled appropriately by the proxy server components, providing meaningful error messages to the user.</p> Example <p>try:     resolved_ip = resolve_dns(\"example.com\") except DNSResolutionError as e:     console.print(f\"[red]Failed to resolve domain: {e}\")</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.exceptions.DNSResolutionError","title":"<code>DNSResolutionError</code>","text":"<p>               Bases: <code>ProxyError</code></p> <p>Raised when DNS resolution fails.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class DNSResolutionError(ProxyError):\n    \"\"\"Raised when DNS resolution fails.\"\"\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.exceptions.ProxyError","title":"<code>ProxyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for proxy errors.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class ProxyError(Exception):\n    \"\"\"Base exception for proxy errors.\"\"\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib","title":"<code>lib</code>","text":"<p>Core proxy library components.</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.SocksHandler","title":"<code>SocksHandler</code>","text":"<p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre> Functions <code>forward(local, remote)</code> <p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre> <code>handle()</code> <p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.SocksProxy","title":"<code>SocksProxy</code>","text":"<p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre> Functions <code>server_bind()</code> <p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.run_server","title":"<code>run_server(host, port)</code>","text":"<p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.dns_handler","title":"<code>dns_handler</code>","text":"<p>DNS resolution using dnspython.</p> Classes <code>DNSResolver</code> <p>Simple DNS resolver using dnspython.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>class DNSResolver:\n    \"\"\"Simple DNS resolver using dnspython.\"\"\"\n\n    # Class-level cache to avoid memory leaks\n    _resolve_cache: ClassVar[dict[str, str]] = {}\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n        self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n        self.resolver.timeout = DEFAULT_TIMEOUT\n        self.resolver.lifetime = DEFAULT_LIFETIME\n        self.resolver.nameservers = DEFAULT_NAMESERVERS\n\n    def resolve(self, domain: str) -&gt; str:\n        \"\"\"Resolve domain name to IP address.\n\n        Args:\n            domain: Domain name to resolve\n\n        Returns:\n            str: Resolved IP address\n\n        Raises:\n            DNSResolutionError: If resolution fails\n        \"\"\"\n        if domain in self._resolve_cache:\n            return self._resolve_cache[domain]\n\n        try:\n            # Try system DNS first (fastest when it works)\n            ip = socket.gethostbyname(domain)\n            self._resolve_cache[domain] = ip\n            return ip\n        except socket.gaierror:\n            try:\n                # Fallback to our configured resolver\n                answer = self.resolver.resolve(domain, \"A\")\n                ip = str(\n                    answer[0]\n                )  # DNS record objects have proper string representation\n                self._resolve_cache[domain] = ip\n                return ip\n            except Exception as dns_error:\n                error_msg = f\"Failed to resolve {domain}\"\n                raise DNSResolutionError(error_msg) from dns_error\n</code></pre> Functions <code>__init__()</code> <p>Initialize the DNS resolver with default settings.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n    self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n    self.resolver.timeout = DEFAULT_TIMEOUT\n    self.resolver.lifetime = DEFAULT_LIFETIME\n    self.resolver.nameservers = DEFAULT_NAMESERVERS\n</code></pre> <code>resolve(domain)</code> <p>Resolve domain name to IP address.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name to resolve</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resolved IP address</p> <p>Raises:</p> Type Description <code>DNSResolutionError</code> <p>If resolution fails</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def resolve(self, domain: str) -&gt; str:\n    \"\"\"Resolve domain name to IP address.\n\n    Args:\n        domain: Domain name to resolve\n\n    Returns:\n        str: Resolved IP address\n\n    Raises:\n        DNSResolutionError: If resolution fails\n    \"\"\"\n    if domain in self._resolve_cache:\n        return self._resolve_cache[domain]\n\n    try:\n        # Try system DNS first (fastest when it works)\n        ip = socket.gethostbyname(domain)\n        self._resolve_cache[domain] = ip\n        return ip\n    except socket.gaierror:\n        try:\n            # Fallback to our configured resolver\n            answer = self.resolver.resolve(domain, \"A\")\n            ip = str(\n                answer[0]\n            )  # DNS record objects have proper string representation\n            self._resolve_cache[domain] = ip\n            return ip\n        except Exception as dns_error:\n            error_msg = f\"Failed to resolve {domain}\"\n            raise DNSResolutionError(error_msg) from dns_error\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_server","title":"<code>proxy_server</code>","text":"<p>SOCKS proxy server implementation with multi-process support.</p> <p>This module implements a multi-process SOCKS proxy server with the following features: - Process pool management for handling multiple connections - Automatic process recovery on failure - WiFi interface detection and validation - Clean shutdown handling - UI integration - Clipboard integration for easy sharing</p> <p>The server supports: - Multiple simultaneous connections - Process-level parallelism - Automatic port reuse - Privilege checking - Interface validation</p> Example Classes <code>SocksProxy</code> <p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre> Functions <code>server_bind()</code> <p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre> Functions <code>create_proxy_server(host, port, num_processes)</code> <p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre> <code>is_wifi_interface(ip)</code> <p>Verify if the IP belongs to the WiFi interface.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def is_wifi_interface(ip: str) -&gt; bool:\n    \"\"\"Verify if the IP belongs to the WiFi interface.\"\"\"\n    for interface, addrs in psutil.net_if_addrs().items():\n        if interface.startswith((\"en\", \"wlan\", \"wifi\", \"eth\")):\n            for addr in addrs:\n                if addr.family == socket.AF_INET and addr.address == ip:\n                    return True\n    return False\n</code></pre> <code>run_server(host, port)</code> <p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_server--create-and-start-a-proxy-server-with-4-processes","title":"Create and start a proxy server with 4 processes","text":"<p>create_proxy_server(\"192.168.1.100\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_stats","title":"<code>proxy_stats</code>","text":"<p>Statistics tracking and monitoring for the SOCKS proxy server.</p> <p>This module provides real-time statistics tracking for the proxy server, including: - Active connection counting - Bandwidth monitoring - Data transfer tracking - Historical bandwidth data</p> <p>The module uses thread-safe operations to track: - Number of active connections - Total bytes sent/received - Bandwidth usage over time - Server uptime</p> <p>The statistics are maintained in a thread-safe manner using locks and are designed to be accessed from multiple processes and threads without race conditions.</p> Example"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_stats--global-stats-object-is-automatically-created","title":"Global stats object is automatically created","text":"<p>from .proxy_stats import proxy_stats</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_stats--track-new-connection","title":"Track new connection","text":"<p>proxy_stats.connection_started()</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.proxy_stats--update-transfer-statistics","title":"Update transfer statistics","text":"<p>proxy_stats.update_bytes(sent=1024, received=2048)</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.socks_handler","title":"<code>socks_handler</code>","text":"<p>SOCKS protocol handler implementation for the proxy server.</p> <p>This module implements the SOCKS5 protocol according to RFC 1928, providing: - Protocol negotiation and handshaking - Authentication methods (currently no-auth) - Address type handling (IPv4 and domain names) - DNS resolution with fallback mechanisms - Bi-directional data forwarding - Connection tracking - Error handling and reporting</p> <p>The handler supports: - CONNECT method - IPv4 addresses - Domain name resolution - Configurable DNS resolvers - Connection statistics tracking - Timeout handling</p> Example Classes <code>SocksHandler</code> <p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre> Functions <code>forward(local, remote)</code> <p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre> <code>handle()</code> <p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.lib.socks_handler--the-handler-is-automatically-used-by-the-socksproxy-server-class","title":"The handler is automatically used by the SocksProxy server class","text":"<p>server = SocksProxy((host, port), SocksHandler) server.serve_forever()</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.network","title":"<code>network</code>","text":"<p>Network interface detection and management.</p> <p>This module provides functionality for: - Scanning available network interfaces - Detecting wireless interfaces - Validating interface status - IP address management - Interface filtering</p> <p>The module prioritizes wireless interfaces and provides detailed information about each interface including: - IP address - Interface status - Wireless capability - Interface name</p> Example <p>interface = scan_interfaces() if interface and interface.is_wireless:     print(f\"Found wireless interface {interface.name} with IP {interface.ip}\")</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.network-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.network.NetworkInterface","title":"<code>NetworkInterface</code>  <code>dataclass</code>","text":"<p>Network interface representation with its key properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Interface name (e.g., 'en0', 'eth0')</p> <code>ip</code> <code>str</code> <p>IPv4 address assigned to the interface</p> <code>is_up</code> <code>bool</code> <p>Boolean indicating if the interface is up and running</p> <code>is_wireless</code> <code>bool</code> <p>Boolean indicating if this is a wireless interface</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>@dataclass\nclass NetworkInterface:\n    \"\"\"Network interface representation with its key properties.\n\n    Attributes:\n        name: Interface name (e.g., 'en0', 'eth0')\n        ip: IPv4 address assigned to the interface\n        is_up: Boolean indicating if the interface is up and running\n        is_wireless: Boolean indicating if this is a wireless interface\n    \"\"\"\n\n    name: str\n    ip: str\n    is_up: bool\n    is_wireless: bool\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.network-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.network.scan_interfaces","title":"<code>scan_interfaces()</code>","text":"<p>Scan for available network interfaces and return the most suitable one.</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>def scan_interfaces() -&gt; NetworkInterface | None:\n    \"\"\"Scan for available network interfaces and return the most suitable one.\"\"\"\n    with Progress() as progress:\n        task = progress.add_task(\"Scanning network interfaces...\", total=1)\n\n        # Get all network interfaces\n        interfaces = []\n        for name, addrs in psutil.net_if_addrs().items():\n            # Skip loopback and virtual interfaces\n            if name.startswith(\n                (\n                    \"lo\",\n                    \"vmnet\",\n                    \"docker\",\n                    \"veth\",\n                    \"bridge\",\n                    \"utun\",\n                    \"llw\",\n                    \"awdl\",\n                    \"anpi\",\n                    \"stf\",\n                    \"gif\",\n                    \"ap\",\n                )\n            ):\n                continue\n\n            # Get IPv4 address\n            ipv4 = next(\n                (addr.address for addr in addrs if addr.family == socket.AF_INET), None\n            )\n            if not ipv4:\n                continue\n\n            # Check if interface is up\n            stats = psutil.net_if_stats().get(name)\n            if not stats or not stats.isup:\n                continue\n\n            # Get interface status\n            try:\n                import shutil\n                import subprocess\n\n                ifconfig_path = shutil.which(\"ifconfig\")\n                if not ifconfig_path:\n                    console.log(\"ifconfig not found\")\n                    continue\n\n                result = subprocess.run(\n                    [ifconfig_path, name], capture_output=True, text=True, check=False\n                )\n                is_active = \"status: active\" in result.stdout\n                if not is_active:\n                    continue\n            except Exception as e:\n                console.log(f\"Error checking interface {name}: {e!s}\")\n                continue\n\n            # Determine if it's a wireless interface (macOS specific)\n            is_wireless = name == \"en0\"  # On macOS, en0 is typically the built-in WiFi\n\n            interfaces.append(\n                NetworkInterface(\n                    name=name, ip=ipv4, is_up=True, is_wireless=is_wireless\n                )\n            )\n\n        progress.update(task, advance=1)\n\n        # First try to find en0 (WiFi on macOS)\n        wifi = next((iface for iface in interfaces if iface.name == \"en0\"), None)\n        if wifi:\n            return wifi\n\n        # Then try other wireless interfaces\n        wireless = [iface for iface in interfaces if iface.is_wireless]\n        if wireless:\n            return wireless[0]\n\n        # Finally, fall back to any available interface\n        if interfaces:\n            return interfaces[0]\n\n        return None\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.proxy","title":"<code>proxy</code>","text":"<p>Core proxy functionality and main entry point for the SOCKS proxy server.</p> <p>This module serves as the main entry point for the SOCKS proxy server functionality. It provides a clean interface to the underlying proxy implementation by exposing only the necessary components through its public API.</p> <p>The module abstracts away the complexity of: - Multi-process SOCKS server management - User interface handling - Statistics tracking - Connection management</p> Example <p>from hotspot_socks_proxy.core.proxy import create_proxy_server</p> <p>Attributes:</p> Name Type Description <code>__all__</code> <code>list</code> <p>List of public components exposed by this module</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.proxy--start-a-socks-proxy-server-on-localhost9050-with-4-processes","title":"Start a SOCKS proxy server on localhost:9050 with 4 processes","text":"<p>create_proxy_server(\"127.0.0.1\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.proxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.proxy.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils","title":"<code>utils</code>","text":"<p>Utility functions and helpers.</p>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils.format_bytes","title":"<code>format_bytes(bytes_)</code>","text":"<p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils.prompt","title":"<code>prompt</code>","text":"<p>Prompt and UI utilities.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre> <code>ProxyUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre> <code>SocksUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre> Modules <code>prompt</code> <p>Base prompt handling and UI components.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre> <code>proxy_ui</code> <p>Proxy-specific UI components.</p> Classes <code>ProxyUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre> <code>socks_ui</code> <p>SOCKS-specific UI components.</p> Classes <code>SocksUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/#hotspot_socks_proxy.core.utils.utils","title":"<code>utils</code>","text":"<p>Common utility functions.</p> Functions <code>format_bytes(bytes_)</code> <p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/exceptions/","title":"hotspot_socks_proxy.core.exceptions","text":""},{"location":"reference/hotspot_socks_proxy/core/exceptions/#hotspot_socks_proxy.core.exceptions","title":"<code>hotspot_socks_proxy.core.exceptions</code>","text":"<p>Custom exceptions for the proxy server.</p> <p>This module defines custom exceptions used throughout the proxy server implementation. These exceptions provide more specific error handling for: - DNS resolution failures - Proxy connection errors - Network interface issues</p> <p>The exceptions are designed to be caught and handled appropriately by the proxy server components, providing meaningful error messages to the user.</p> Example <p>try:     resolved_ip = resolve_dns(\"example.com\") except DNSResolutionError as e:     console.print(f\"[red]Failed to resolve domain: {e}\")</p>"},{"location":"reference/hotspot_socks_proxy/core/exceptions/#hotspot_socks_proxy.core.exceptions-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/exceptions/#hotspot_socks_proxy.core.exceptions.DNSResolutionError","title":"<code>DNSResolutionError</code>","text":"<p>               Bases: <code>ProxyError</code></p> <p>Raised when DNS resolution fails.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class DNSResolutionError(ProxyError):\n    \"\"\"Raised when DNS resolution fails.\"\"\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/exceptions/#hotspot_socks_proxy.core.exceptions.ProxyError","title":"<code>ProxyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for proxy errors.</p> Source code in <code>src/hotspot_socks_proxy/core/exceptions.py</code> <pre><code>class ProxyError(Exception):\n    \"\"\"Base exception for proxy errors.\"\"\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/network/","title":"hotspot_socks_proxy.core.network","text":""},{"location":"reference/hotspot_socks_proxy/core/network/#hotspot_socks_proxy.core.network","title":"<code>hotspot_socks_proxy.core.network</code>","text":"<p>Network interface detection and management.</p> <p>This module provides functionality for: - Scanning available network interfaces - Detecting wireless interfaces - Validating interface status - IP address management - Interface filtering</p> <p>The module prioritizes wireless interfaces and provides detailed information about each interface including: - IP address - Interface status - Wireless capability - Interface name</p> Example <p>interface = scan_interfaces() if interface and interface.is_wireless:     print(f\"Found wireless interface {interface.name} with IP {interface.ip}\")</p>"},{"location":"reference/hotspot_socks_proxy/core/network/#hotspot_socks_proxy.core.network-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/network/#hotspot_socks_proxy.core.network.NetworkInterface","title":"<code>NetworkInterface</code>  <code>dataclass</code>","text":"<p>Network interface representation with its key properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Interface name (e.g., 'en0', 'eth0')</p> <code>ip</code> <code>str</code> <p>IPv4 address assigned to the interface</p> <code>is_up</code> <code>bool</code> <p>Boolean indicating if the interface is up and running</p> <code>is_wireless</code> <code>bool</code> <p>Boolean indicating if this is a wireless interface</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>@dataclass\nclass NetworkInterface:\n    \"\"\"Network interface representation with its key properties.\n\n    Attributes:\n        name: Interface name (e.g., 'en0', 'eth0')\n        ip: IPv4 address assigned to the interface\n        is_up: Boolean indicating if the interface is up and running\n        is_wireless: Boolean indicating if this is a wireless interface\n    \"\"\"\n\n    name: str\n    ip: str\n    is_up: bool\n    is_wireless: bool\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/network/#hotspot_socks_proxy.core.network-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/network/#hotspot_socks_proxy.core.network.scan_interfaces","title":"<code>scan_interfaces()</code>","text":"<p>Scan for available network interfaces and return the most suitable one.</p> Source code in <code>src/hotspot_socks_proxy/core/network.py</code> <pre><code>def scan_interfaces() -&gt; NetworkInterface | None:\n    \"\"\"Scan for available network interfaces and return the most suitable one.\"\"\"\n    with Progress() as progress:\n        task = progress.add_task(\"Scanning network interfaces...\", total=1)\n\n        # Get all network interfaces\n        interfaces = []\n        for name, addrs in psutil.net_if_addrs().items():\n            # Skip loopback and virtual interfaces\n            if name.startswith(\n                (\n                    \"lo\",\n                    \"vmnet\",\n                    \"docker\",\n                    \"veth\",\n                    \"bridge\",\n                    \"utun\",\n                    \"llw\",\n                    \"awdl\",\n                    \"anpi\",\n                    \"stf\",\n                    \"gif\",\n                    \"ap\",\n                )\n            ):\n                continue\n\n            # Get IPv4 address\n            ipv4 = next(\n                (addr.address for addr in addrs if addr.family == socket.AF_INET), None\n            )\n            if not ipv4:\n                continue\n\n            # Check if interface is up\n            stats = psutil.net_if_stats().get(name)\n            if not stats or not stats.isup:\n                continue\n\n            # Get interface status\n            try:\n                import shutil\n                import subprocess\n\n                ifconfig_path = shutil.which(\"ifconfig\")\n                if not ifconfig_path:\n                    console.log(\"ifconfig not found\")\n                    continue\n\n                result = subprocess.run(\n                    [ifconfig_path, name], capture_output=True, text=True, check=False\n                )\n                is_active = \"status: active\" in result.stdout\n                if not is_active:\n                    continue\n            except Exception as e:\n                console.log(f\"Error checking interface {name}: {e!s}\")\n                continue\n\n            # Determine if it's a wireless interface (macOS specific)\n            is_wireless = name == \"en0\"  # On macOS, en0 is typically the built-in WiFi\n\n            interfaces.append(\n                NetworkInterface(\n                    name=name, ip=ipv4, is_up=True, is_wireless=is_wireless\n                )\n            )\n\n        progress.update(task, advance=1)\n\n        # First try to find en0 (WiFi on macOS)\n        wifi = next((iface for iface in interfaces if iface.name == \"en0\"), None)\n        if wifi:\n            return wifi\n\n        # Then try other wireless interfaces\n        wireless = [iface for iface in interfaces if iface.is_wireless]\n        if wireless:\n            return wireless[0]\n\n        # Finally, fall back to any available interface\n        if interfaces:\n            return interfaces[0]\n\n        return None\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/proxy/","title":"hotspot_socks_proxy.core.proxy","text":""},{"location":"reference/hotspot_socks_proxy/core/proxy/#hotspot_socks_proxy.core.proxy","title":"<code>hotspot_socks_proxy.core.proxy</code>","text":"<p>Core proxy functionality and main entry point for the SOCKS proxy server.</p> <p>This module serves as the main entry point for the SOCKS proxy server functionality. It provides a clean interface to the underlying proxy implementation by exposing only the necessary components through its public API.</p> <p>The module abstracts away the complexity of: - Multi-process SOCKS server management - User interface handling - Statistics tracking - Connection management</p> Example <p>from hotspot_socks_proxy.core.proxy import create_proxy_server</p> <p>Attributes:</p> Name Type Description <code>__all__</code> <code>list</code> <p>List of public components exposed by this module</p>"},{"location":"reference/hotspot_socks_proxy/core/proxy/#hotspot_socks_proxy.core.proxy--start-a-socks-proxy-server-on-localhost9050-with-4-processes","title":"Start a SOCKS proxy server on localhost:9050 with 4 processes","text":"<p>create_proxy_server(\"127.0.0.1\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/core/proxy/#hotspot_socks_proxy.core.proxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/proxy/#hotspot_socks_proxy.core.proxy.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/","title":"hotspot_socks_proxy.core.lib","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib","title":"<code>hotspot_socks_proxy.core.lib</code>","text":"<p>Core proxy library components.</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksHandler","title":"<code>SocksHandler</code>","text":"<p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksHandler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksHandler.forward","title":"<code>forward(local, remote)</code>","text":"<p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksHandler.handle","title":"<code>handle()</code>","text":"<p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksProxy","title":"<code>SocksProxy</code>","text":"<p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksProxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.SocksProxy.server_bind","title":"<code>server_bind()</code>","text":"<p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.run_server","title":"<code>run_server(host, port)</code>","text":"<p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.dns_handler","title":"<code>dns_handler</code>","text":"<p>DNS resolution using dnspython.</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.dns_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.dns_handler.DNSResolver","title":"<code>DNSResolver</code>","text":"<p>Simple DNS resolver using dnspython.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>class DNSResolver:\n    \"\"\"Simple DNS resolver using dnspython.\"\"\"\n\n    # Class-level cache to avoid memory leaks\n    _resolve_cache: ClassVar[dict[str, str]] = {}\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n        self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n        self.resolver.timeout = DEFAULT_TIMEOUT\n        self.resolver.lifetime = DEFAULT_LIFETIME\n        self.resolver.nameservers = DEFAULT_NAMESERVERS\n\n    def resolve(self, domain: str) -&gt; str:\n        \"\"\"Resolve domain name to IP address.\n\n        Args:\n            domain: Domain name to resolve\n\n        Returns:\n            str: Resolved IP address\n\n        Raises:\n            DNSResolutionError: If resolution fails\n        \"\"\"\n        if domain in self._resolve_cache:\n            return self._resolve_cache[domain]\n\n        try:\n            # Try system DNS first (fastest when it works)\n            ip = socket.gethostbyname(domain)\n            self._resolve_cache[domain] = ip\n            return ip\n        except socket.gaierror:\n            try:\n                # Fallback to our configured resolver\n                answer = self.resolver.resolve(domain, \"A\")\n                ip = str(\n                    answer[0]\n                )  # DNS record objects have proper string representation\n                self._resolve_cache[domain] = ip\n                return ip\n            except Exception as dns_error:\n                error_msg = f\"Failed to resolve {domain}\"\n                raise DNSResolutionError(error_msg) from dns_error\n</code></pre> Functions <code>__init__()</code> <p>Initialize the DNS resolver with default settings.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n    self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n    self.resolver.timeout = DEFAULT_TIMEOUT\n    self.resolver.lifetime = DEFAULT_LIFETIME\n    self.resolver.nameservers = DEFAULT_NAMESERVERS\n</code></pre> <code>resolve(domain)</code> <p>Resolve domain name to IP address.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name to resolve</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resolved IP address</p> <p>Raises:</p> Type Description <code>DNSResolutionError</code> <p>If resolution fails</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def resolve(self, domain: str) -&gt; str:\n    \"\"\"Resolve domain name to IP address.\n\n    Args:\n        domain: Domain name to resolve\n\n    Returns:\n        str: Resolved IP address\n\n    Raises:\n        DNSResolutionError: If resolution fails\n    \"\"\"\n    if domain in self._resolve_cache:\n        return self._resolve_cache[domain]\n\n    try:\n        # Try system DNS first (fastest when it works)\n        ip = socket.gethostbyname(domain)\n        self._resolve_cache[domain] = ip\n        return ip\n    except socket.gaierror:\n        try:\n            # Fallback to our configured resolver\n            answer = self.resolver.resolve(domain, \"A\")\n            ip = str(\n                answer[0]\n            )  # DNS record objects have proper string representation\n            self._resolve_cache[domain] = ip\n            return ip\n        except Exception as dns_error:\n            error_msg = f\"Failed to resolve {domain}\"\n            raise DNSResolutionError(error_msg) from dns_error\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server","title":"<code>proxy_server</code>","text":"<p>SOCKS proxy server implementation with multi-process support.</p> <p>This module implements a multi-process SOCKS proxy server with the following features: - Process pool management for handling multiple connections - Automatic process recovery on failure - WiFi interface detection and validation - Clean shutdown handling - UI integration - Clipboard integration for easy sharing</p> <p>The server supports: - Multiple simultaneous connections - Process-level parallelism - Automatic port reuse - Privilege checking - Interface validation</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server--create-and-start-a-proxy-server-with-4-processes","title":"Create and start a proxy server with 4 processes","text":"<p>create_proxy_server(\"192.168.1.100\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server.SocksProxy","title":"<code>SocksProxy</code>","text":"<p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre> Functions <code>server_bind()</code> <p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server.is_wifi_interface","title":"<code>is_wifi_interface(ip)</code>","text":"<p>Verify if the IP belongs to the WiFi interface.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def is_wifi_interface(ip: str) -&gt; bool:\n    \"\"\"Verify if the IP belongs to the WiFi interface.\"\"\"\n    for interface, addrs in psutil.net_if_addrs().items():\n        if interface.startswith((\"en\", \"wlan\", \"wifi\", \"eth\")):\n            for addr in addrs:\n                if addr.family == socket.AF_INET and addr.address == ip:\n                    return True\n    return False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_server.run_server","title":"<code>run_server(host, port)</code>","text":"<p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_stats","title":"<code>proxy_stats</code>","text":"<p>Statistics tracking and monitoring for the SOCKS proxy server.</p> <p>This module provides real-time statistics tracking for the proxy server, including: - Active connection counting - Bandwidth monitoring - Data transfer tracking - Historical bandwidth data</p> <p>The module uses thread-safe operations to track: - Number of active connections - Total bytes sent/received - Bandwidth usage over time - Server uptime</p> <p>The statistics are maintained in a thread-safe manner using locks and are designed to be accessed from multiple processes and threads without race conditions.</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_stats--global-stats-object-is-automatically-created","title":"Global stats object is automatically created","text":"<p>from .proxy_stats import proxy_stats</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_stats--track-new-connection","title":"Track new connection","text":"<p>proxy_stats.connection_started()</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.proxy_stats--update-transfer-statistics","title":"Update transfer statistics","text":"<p>proxy_stats.update_bytes(sent=1024, received=2048)</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.socks_handler","title":"<code>socks_handler</code>","text":"<p>SOCKS protocol handler implementation for the proxy server.</p> <p>This module implements the SOCKS5 protocol according to RFC 1928, providing: - Protocol negotiation and handshaking - Authentication methods (currently no-auth) - Address type handling (IPv4 and domain names) - DNS resolution with fallback mechanisms - Bi-directional data forwarding - Connection tracking - Error handling and reporting</p> <p>The handler supports: - CONNECT method - IPv4 addresses - Domain name resolution - Configurable DNS resolvers - Connection statistics tracking - Timeout handling</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.socks_handler--the-handler-is-automatically-used-by-the-socksproxy-server-class","title":"The handler is automatically used by the SocksProxy server class","text":"<p>server = SocksProxy((host, port), SocksHandler) server.serve_forever()</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.socks_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/#hotspot_socks_proxy.core.lib.socks_handler.SocksHandler","title":"<code>SocksHandler</code>","text":"<p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre> Functions <code>forward(local, remote)</code> <p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre> <code>handle()</code> <p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/","title":"hotspot_socks_proxy.core.lib.dns_handler","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler","title":"<code>hotspot_socks_proxy.core.lib.dns_handler</code>","text":"<p>DNS resolution using dnspython.</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler.DNSResolver","title":"<code>DNSResolver</code>","text":"<p>Simple DNS resolver using dnspython.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>class DNSResolver:\n    \"\"\"Simple DNS resolver using dnspython.\"\"\"\n\n    # Class-level cache to avoid memory leaks\n    _resolve_cache: ClassVar[dict[str, str]] = {}\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n        self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n        self.resolver.timeout = DEFAULT_TIMEOUT\n        self.resolver.lifetime = DEFAULT_LIFETIME\n        self.resolver.nameservers = DEFAULT_NAMESERVERS\n\n    def resolve(self, domain: str) -&gt; str:\n        \"\"\"Resolve domain name to IP address.\n\n        Args:\n            domain: Domain name to resolve\n\n        Returns:\n            str: Resolved IP address\n\n        Raises:\n            DNSResolutionError: If resolution fails\n        \"\"\"\n        if domain in self._resolve_cache:\n            return self._resolve_cache[domain]\n\n        try:\n            # Try system DNS first (fastest when it works)\n            ip = socket.gethostbyname(domain)\n            self._resolve_cache[domain] = ip\n            return ip\n        except socket.gaierror:\n            try:\n                # Fallback to our configured resolver\n                answer = self.resolver.resolve(domain, \"A\")\n                ip = str(\n                    answer[0]\n                )  # DNS record objects have proper string representation\n                self._resolve_cache[domain] = ip\n                return ip\n            except Exception as dns_error:\n                error_msg = f\"Failed to resolve {domain}\"\n                raise DNSResolutionError(error_msg) from dns_error\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler.DNSResolver-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler.DNSResolver.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the DNS resolver with default settings.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the DNS resolver with default settings.\"\"\"\n    self.resolver = cast(\"Resolver\", dns.resolver.Resolver())\n    self.resolver.timeout = DEFAULT_TIMEOUT\n    self.resolver.lifetime = DEFAULT_LIFETIME\n    self.resolver.nameservers = DEFAULT_NAMESERVERS\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/dns_handler/#hotspot_socks_proxy.core.lib.dns_handler.DNSResolver.resolve","title":"<code>resolve(domain)</code>","text":"<p>Resolve domain name to IP address.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name to resolve</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Resolved IP address</p> <p>Raises:</p> Type Description <code>DNSResolutionError</code> <p>If resolution fails</p> Source code in <code>src/hotspot_socks_proxy/core/lib/dns_handler.py</code> <pre><code>def resolve(self, domain: str) -&gt; str:\n    \"\"\"Resolve domain name to IP address.\n\n    Args:\n        domain: Domain name to resolve\n\n    Returns:\n        str: Resolved IP address\n\n    Raises:\n        DNSResolutionError: If resolution fails\n    \"\"\"\n    if domain in self._resolve_cache:\n        return self._resolve_cache[domain]\n\n    try:\n        # Try system DNS first (fastest when it works)\n        ip = socket.gethostbyname(domain)\n        self._resolve_cache[domain] = ip\n        return ip\n    except socket.gaierror:\n        try:\n            # Fallback to our configured resolver\n            answer = self.resolver.resolve(domain, \"A\")\n            ip = str(\n                answer[0]\n            )  # DNS record objects have proper string representation\n            self._resolve_cache[domain] = ip\n            return ip\n        except Exception as dns_error:\n            error_msg = f\"Failed to resolve {domain}\"\n            raise DNSResolutionError(error_msg) from dns_error\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/","title":"hotspot_socks_proxy.core.lib.proxy_server","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server","title":"<code>hotspot_socks_proxy.core.lib.proxy_server</code>","text":"<p>SOCKS proxy server implementation with multi-process support.</p> <p>This module implements a multi-process SOCKS proxy server with the following features: - Process pool management for handling multiple connections - Automatic process recovery on failure - WiFi interface detection and validation - Clean shutdown handling - UI integration - Clipboard integration for easy sharing</p> <p>The server supports: - Multiple simultaneous connections - Process-level parallelism - Automatic port reuse - Privilege checking - Interface validation</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server--create-and-start-a-proxy-server-with-4-processes","title":"Create and start a proxy server with 4 processes","text":"<p>create_proxy_server(\"192.168.1.100\", 9050, 4)</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.SocksProxy","title":"<code>SocksProxy</code>","text":"<p>               Bases: <code>ThreadingMixIn</code>, <code>TCPServer</code></p> <p>SOCKS proxy server implementation.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>class SocksProxy(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    \"\"\"SOCKS proxy server implementation.\"\"\"\n\n    allow_reuse_address = True\n    daemon_threads = True\n    request_queue_size = 100\n\n    def server_bind(self) -&gt; None:\n        \"\"\"Bind the server socket with reuse options.\"\"\"\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.SocksProxy-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.SocksProxy.server_bind","title":"<code>server_bind()</code>","text":"<p>Bind the server socket with reuse options.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def server_bind(self) -&gt; None:\n    \"\"\"Bind the server socket with reuse options.\"\"\"\n    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(socket, \"SO_REUSEPORT\"):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n    super().server_bind()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.create_proxy_server","title":"<code>create_proxy_server(host, port, num_processes)</code>","text":"<p>Create and start a multi-process SOCKS proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required <code>num_processes</code> <code>int</code> <p>Number of worker processes to start</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def create_proxy_server(host: str, port: int, num_processes: int) -&gt; None:\n    \"\"\"Create and start a multi-process SOCKS proxy server.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n        num_processes: Number of worker processes to start\n    \"\"\"\n    processes: ProcessList = []\n\n    try:\n        # Initialize UI\n        ui_thread = create_proxy_ui(host, port)\n        if ui_thread:\n            ui_thread.start()\n\n        # Copy address to clipboard\n        try:\n            proxy_address = f\"{host}:{port}\"\n            pyperclip.copy(proxy_address)\n            console.print(\"[bold green]Proxy address copied to clipboard\")\n            time.sleep(CLIPBOARD_DELAY)\n        except Exception as e:\n            console.print(f\"[yellow]Could not copy to clipboard: {e}\")\n\n        # Start worker processes\n        console.print(f\"[bold green]Starting {num_processes} worker processes...\")\n        for _ in range(num_processes):\n            process = multiprocessing.Process(target=run_server, args=(host, port))\n            process.daemon = True\n            processes.append(process)\n            process.start()\n            time.sleep(STARTUP_DELAY)\n\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Shutting down proxy server...\")\n    finally:\n        for process in processes:\n            if process.is_alive():\n                process.terminate()\n                process.join(timeout=PROCESS_JOIN_TIMEOUT)\n                if process.is_alive():\n                    process.kill()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.is_wifi_interface","title":"<code>is_wifi_interface(ip)</code>","text":"<p>Verify if the IP belongs to the WiFi interface.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def is_wifi_interface(ip: str) -&gt; bool:\n    \"\"\"Verify if the IP belongs to the WiFi interface.\"\"\"\n    for interface, addrs in psutil.net_if_addrs().items():\n        if interface.startswith((\"en\", \"wlan\", \"wifi\", \"eth\")):\n            for addr in addrs:\n                if addr.family == socket.AF_INET and addr.address == ip:\n                    return True\n    return False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_server/#hotspot_socks_proxy.core.lib.proxy_server.run_server","title":"<code>run_server(host, port)</code>","text":"<p>Individual process server runner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to</p> required <code>port</code> <code>int</code> <p>Port number to listen on</p> required Source code in <code>src/hotspot_socks_proxy/core/lib/proxy_server.py</code> <pre><code>def run_server(host: str, port: int) -&gt; None:\n    \"\"\"Individual process server runner.\n\n    Args:\n        host: Host address to bind to\n        port: Port number to listen on\n    \"\"\"\n    server: SocksProxy | None = None\n    try:\n        if not is_wifi_interface(host):\n            console.print(f\"[red]Error: {host} is not the WiFi interface IP\")\n            return\n\n        if os.name != \"nt\" and os.geteuid() != 0:\n            console.print(\n                \"[yellow]Warning: Running without root privileges may limit functionality.\"\n            )\n\n        server = SocksProxy((host, port), SocksHandler)\n        server.serve_forever()\n    except KeyboardInterrupt:\n        pass\n    except Exception as e:\n        console.print(f\"[red]Server error: {e}\")\n    finally:\n        if server:\n            with contextlib.suppress(Exception):\n                server.server_close()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_stats/","title":"hotspot_socks_proxy.core.lib.proxy_stats","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_stats/#hotspot_socks_proxy.core.lib.proxy_stats","title":"<code>hotspot_socks_proxy.core.lib.proxy_stats</code>","text":"<p>Statistics tracking and monitoring for the SOCKS proxy server.</p> <p>This module provides real-time statistics tracking for the proxy server, including: - Active connection counting - Bandwidth monitoring - Data transfer tracking - Historical bandwidth data</p> <p>The module uses thread-safe operations to track: - Number of active connections - Total bytes sent/received - Bandwidth usage over time - Server uptime</p> <p>The statistics are maintained in a thread-safe manner using locks and are designed to be accessed from multiple processes and threads without race conditions.</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_stats/#hotspot_socks_proxy.core.lib.proxy_stats--global-stats-object-is-automatically-created","title":"Global stats object is automatically created","text":"<p>from .proxy_stats import proxy_stats</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_stats/#hotspot_socks_proxy.core.lib.proxy_stats--track-new-connection","title":"Track new connection","text":"<p>proxy_stats.connection_started()</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/proxy_stats/#hotspot_socks_proxy.core.lib.proxy_stats--update-transfer-statistics","title":"Update transfer statistics","text":"<p>proxy_stats.update_bytes(sent=1024, received=2048)</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/","title":"hotspot_socks_proxy.core.lib.socks_handler","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler","title":"<code>hotspot_socks_proxy.core.lib.socks_handler</code>","text":"<p>SOCKS protocol handler implementation for the proxy server.</p> <p>This module implements the SOCKS5 protocol according to RFC 1928, providing: - Protocol negotiation and handshaking - Authentication methods (currently no-auth) - Address type handling (IPv4 and domain names) - DNS resolution with fallback mechanisms - Bi-directional data forwarding - Connection tracking - Error handling and reporting</p> <p>The handler supports: - CONNECT method - IPv4 addresses - Domain name resolution - Configurable DNS resolvers - Connection statistics tracking - Timeout handling</p> Example"},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler--the-handler-is-automatically-used-by-the-socksproxy-server-class","title":"The handler is automatically used by the SocksProxy server class","text":"<p>server = SocksProxy((host, port), SocksHandler) server.serve_forever()</p>"},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler.SocksHandler","title":"<code>SocksHandler</code>","text":"<p>               Bases: <code>BaseRequestHandler</code></p> <p>Handle incoming SOCKS5 connections.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>class SocksHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handle incoming SOCKS5 connections.\"\"\"\n\n    def _negotiate(self) -&gt; bool:\n        \"\"\"Perform SOCKS5 protocol negotiation.\"\"\"\n        # Get auth methods\n        version, nmethods = struct.unpack(\"!BB\", self.request.recv(2))\n        if version != SOCKS_VERSION:\n            return False\n\n        # Get available methods and ignore them since we only support no-auth\n        self.request.recv(nmethods)\n\n        # Send auth method choice (0 = no auth)\n        self.request.send(struct.pack(\"!BB\", SOCKS_VERSION, 0))\n        return True\n\n    def _send_response(\n        self, status: int, bind_addr: str = \"127.0.0.1\", bind_port: int = 0\n    ) -&gt; None:\n        \"\"\"Send SOCKS5 response.\"\"\"\n        # Convert bind address to bytes\n        addr_bytes = socket.inet_aton(bind_addr)\n\n        # Create response packet\n        response = struct.pack(\"!BBBB\", SOCKS_VERSION, status, 0, ADDR_TYPE_IPV4)\n        response += addr_bytes + struct.pack(\"!H\", bind_port)\n\n        self.request.send(response)\n\n    def handle(self) -&gt; None:\n        \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n        client_addr = self.client_address\n        socks_ui.connection_started(client_addr)\n        try:\n            # SOCKS5 initialization\n            if not self._negotiate():\n                return\n\n            # Get command and address\n            version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n            if version != SOCKS_VERSION:\n                return\n\n            if cmd != CONNECT_CMD:  # Only support CONNECT\n                self._send_response(RESP_CMD_NOT_SUPPORTED)\n                return\n\n            # Handle different address types\n            if addr_type == ADDR_TYPE_IPV4:  # IPv4\n                addr = socket.inet_ntoa(self.request.recv(4))\n            elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n                domain_len = self.request.recv(1)[0]\n                addr = self.request.recv(domain_len).decode()\n            else:\n                self._send_response(RESP_ADDR_NOT_SUPPORTED)\n                return\n\n            port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n            # Connect to remote\n            try:\n                remote = socket.create_connection((addr, port), timeout=10)\n                bound_addr = remote.getsockname()\n                self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n            except OSError as conn_error:\n                console.print(f\"[red]Connection failed: {conn_error}\")\n                self._send_response(RESP_HOST_UNREACHABLE)\n                return\n\n            self.forward(self.request, remote)\n\n        except Exception as exc:\n            console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n        finally:\n            socks_ui.connection_ended(client_addr)\n            proxy_stats.connection_ended()\n\n    def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n        \"\"\"Forward data between local and remote sockets.\"\"\"\n        while True:\n            r, w, e = select.select([local, remote], [], [], 60)\n\n            if not r:  # Timeout\n                break\n\n            for sock in r:\n                other = remote if sock is local else local\n                try:\n                    data = sock.recv(4096)\n                    if not data:\n                        return\n                    other.send(data)\n                    proxy_stats.update_bytes(\n                        len(data), 0 if sock is local else len(data)\n                    )\n                except OSError as sock_error:\n                    console.print(f\"[red]Forward error: {sock_error}\")\n                    return\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler.SocksHandler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler.SocksHandler.forward","title":"<code>forward(local, remote)</code>","text":"<p>Forward data between local and remote sockets.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def forward(self, local: socket.socket, remote: socket.socket) -&gt; None:\n    \"\"\"Forward data between local and remote sockets.\"\"\"\n    while True:\n        r, w, e = select.select([local, remote], [], [], 60)\n\n        if not r:  # Timeout\n            break\n\n        for sock in r:\n            other = remote if sock is local else local\n            try:\n                data = sock.recv(4096)\n                if not data:\n                    return\n                other.send(data)\n                proxy_stats.update_bytes(\n                    len(data), 0 if sock is local else len(data)\n                )\n            except OSError as sock_error:\n                console.print(f\"[red]Forward error: {sock_error}\")\n                return\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/lib/socks_handler/#hotspot_socks_proxy.core.lib.socks_handler.SocksHandler.handle","title":"<code>handle()</code>","text":"<p>Handle incoming SOCKS5 connection.</p> Source code in <code>src/hotspot_socks_proxy/core/lib/socks_handler.py</code> <pre><code>def handle(self) -&gt; None:\n    \"\"\"Handle incoming SOCKS5 connection.\"\"\"\n    client_addr = self.client_address\n    socks_ui.connection_started(client_addr)\n    try:\n        # SOCKS5 initialization\n        if not self._negotiate():\n            return\n\n        # Get command and address\n        version, cmd, _, addr_type = struct.unpack(\"!BBBB\", self.request.recv(4))\n\n        if version != SOCKS_VERSION:\n            return\n\n        if cmd != CONNECT_CMD:  # Only support CONNECT\n            self._send_response(RESP_CMD_NOT_SUPPORTED)\n            return\n\n        # Handle different address types\n        if addr_type == ADDR_TYPE_IPV4:  # IPv4\n            addr = socket.inet_ntoa(self.request.recv(4))\n        elif addr_type == ADDR_TYPE_DOMAIN:  # Domain name\n            domain_len = self.request.recv(1)[0]\n            addr = self.request.recv(domain_len).decode()\n        else:\n            self._send_response(RESP_ADDR_NOT_SUPPORTED)\n            return\n\n        port = struct.unpack(\"!H\", self.request.recv(2))[0]\n\n        # Connect to remote\n        try:\n            remote = socket.create_connection((addr, port), timeout=10)\n            bound_addr = remote.getsockname()\n            self._send_response(RESP_SUCCESS, bound_addr[0], bound_addr[1])\n        except OSError as conn_error:\n            console.print(f\"[red]Connection failed: {conn_error}\")\n            self._send_response(RESP_HOST_UNREACHABLE)\n            return\n\n        self.forward(self.request, remote)\n\n    except Exception as exc:\n        console.print(f\"[red]Error handling SOCKS connection: {exc}\")\n    finally:\n        socks_ui.connection_ended(client_addr)\n        proxy_stats.connection_ended()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/","title":"hotspot_socks_proxy.core.utils","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils","title":"<code>hotspot_socks_proxy.core.utils</code>","text":"<p>Utility functions and helpers.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.PromptHandler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.PromptHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.PromptHandler.create_live_display","title":"<code>create_live_display(content, refresh_per_second=2)</code>","text":"<p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.format_bytes","title":"<code>format_bytes(bytes_)</code>","text":"<p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt","title":"<code>prompt</code>","text":"<p>Prompt and UI utilities.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.ProxyUI","title":"<code>ProxyUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.SocksUI","title":"<code>SocksUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.prompt","title":"<code>prompt</code>","text":"<p>Base prompt handling and UI components.</p> Classes <code>PromptHandler</code> <p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.proxy_ui","title":"<code>proxy_ui</code>","text":"<p>Proxy-specific UI components.</p> Classes <code>ProxyUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre> Functions <code>create_proxy_ui(host, port)</code> <p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.prompt.socks_ui","title":"<code>socks_ui</code>","text":"<p>SOCKS-specific UI components.</p> Classes <code>SocksUI</code> <p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.utils","title":"<code>utils</code>","text":"<p>Common utility functions.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.utils-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/#hotspot_socks_proxy.core.utils.utils.format_bytes","title":"<code>format_bytes(bytes_)</code>","text":"<p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/utils/","title":"hotspot_socks_proxy.core.utils.utils","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/utils/#hotspot_socks_proxy.core.utils.utils","title":"<code>hotspot_socks_proxy.core.utils.utils</code>","text":"<p>Common utility functions.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/utils/#hotspot_socks_proxy.core.utils.utils-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/utils/#hotspot_socks_proxy.core.utils.utils.format_bytes","title":"<code>format_bytes(bytes_)</code>","text":"<p>Format bytes into human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_</code> <code>float</code> <p>Number of bytes to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string with appropriate unit</p> Source code in <code>src/hotspot_socks_proxy/core/utils/utils.py</code> <pre><code>def format_bytes(bytes_: float) -&gt; str:\n    \"\"\"Format bytes into human readable format.\n\n    Args:\n        bytes_: Number of bytes to format\n\n    Returns:\n        str: Formatted string with appropriate unit\n    \"\"\"\n    for unit, divisor in SIZE_UNITS:\n        if bytes_ &lt; divisor * BYTES_PER_KB:\n            return f\"{bytes_ / divisor:.1f} {unit}\"\n    return f\"{bytes_ / BYTES_PER_TB:.1f} TB\"\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/","title":"hotspot_socks_proxy.core.utils.prompt","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt","title":"<code>hotspot_socks_proxy.core.utils.prompt</code>","text":"<p>Prompt and UI utilities.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.PromptHandler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.PromptHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.PromptHandler.create_live_display","title":"<code>create_live_display(content, refresh_per_second=2)</code>","text":"<p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.ProxyUI","title":"<code>ProxyUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.ProxyUI-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.ProxyUI.__init__","title":"<code>__init__(server_ip, port=9050)</code>","text":"<p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.ProxyUI.run","title":"<code>run()</code>","text":"<p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.SocksUI","title":"<code>SocksUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.SocksUI-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.SocksUI.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.SocksUI.connection_ended","title":"<code>connection_ended(addr)</code>","text":"<p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.SocksUI.connection_started","title":"<code>connection_started(addr)</code>","text":"<p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt-modules","title":"Modules","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt","title":"<code>prompt</code>","text":"<p>Base prompt handling and UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre> Functions <code>__init__()</code> <p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre> <code>create_live_display(content, refresh_per_second=2)</code> <p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.proxy_ui","title":"<code>proxy_ui</code>","text":"<p>Proxy-specific UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.proxy_ui-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.ProxyUI","title":"<code>ProxyUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre> Functions <code>__init__(server_ip, port=9050)</code> <p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre> <code>run()</code> <p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.proxy_ui-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.socks_ui","title":"<code>socks_ui</code>","text":"<p>SOCKS-specific UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.socks_ui-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI","title":"<code>SocksUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre> Functions <code>__init__()</code> <p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre> <code>connection_ended(addr)</code> <p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre> <code>connection_started(addr)</code> <p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/","title":"hotspot_socks_proxy.core.utils.prompt.prompt","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt","title":"<code>hotspot_socks_proxy.core.utils.prompt.prompt</code>","text":"<p>Base prompt handling and UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt.PromptHandler","title":"<code>PromptHandler</code>","text":"<p>Base class for handling terminal prompts and UI.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>class PromptHandler:\n    \"\"\"Base class for handling terminal prompts and UI.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PromptHandler with default settings.\n\n        Sets up the refresh rate and spinner style for terminal displays.\n        \"\"\"\n        self._refresh_rate = 1.0\n        self._spinner = Spinner(\"dots\")\n\n    def create_live_display(self, content, refresh_per_second: int = 2):\n        \"\"\"Create a live updating display.\"\"\"\n        return Live(\n            content,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt.PromptHandler-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt.PromptHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PromptHandler with default settings.</p> <p>Sets up the refresh rate and spinner style for terminal displays.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PromptHandler with default settings.\n\n    Sets up the refresh rate and spinner style for terminal displays.\n    \"\"\"\n    self._refresh_rate = 1.0\n    self._spinner = Spinner(\"dots\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/prompt/#hotspot_socks_proxy.core.utils.prompt.prompt.PromptHandler.create_live_display","title":"<code>create_live_display(content, refresh_per_second=2)</code>","text":"<p>Create a live updating display.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/prompt.py</code> <pre><code>def create_live_display(self, content, refresh_per_second: int = 2):\n    \"\"\"Create a live updating display.\"\"\"\n    return Live(\n        content,\n        console=console,\n        refresh_per_second=refresh_per_second,\n        transient=True,\n    )\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/","title":"hotspot_socks_proxy.core.utils.prompt.proxy_ui","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui","title":"<code>hotspot_socks_proxy.core.utils.prompt.proxy_ui</code>","text":"<p>Proxy-specific UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.ProxyUI","title":"<code>ProxyUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for the proxy server.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>class ProxyUI(PromptHandler):\n    \"\"\"UI handler for the proxy server.\"\"\"\n\n    def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n        \"\"\"Initialize the proxy UI handler.\n\n        Args:\n            server_ip: IP address of the proxy server\n            port: Port number the proxy server is listening on (default: 9050)\n        \"\"\"\n        super().__init__()\n        self.server_ip = server_ip\n        self.port = port\n        self.running = True\n        self._last_bandwidth = 0\n        self._start_time = time.monotonic()\n        self._refresh_rate = 0.5\n        self._spinner = Spinner(\"dots\", text=\"\")\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        bandwidth = proxy_stats.get_bandwidth()\n        if abs(bandwidth - self._last_bandwidth) &gt; BANDWIDTH_THRESHOLD:\n            self._last_bandwidth = bandwidth\n\n        elapsed = time.monotonic() - self._start_time\n        spinner_text = self._spinner.render(elapsed)\n\n        table.add_row(\n            \"Bandwidth\", f\"{spinner_text} {format_bytes(self._last_bandwidth)}/s\"\n        )\n        table.add_row(\"Active Connections\", str(proxy_stats.active_connections))\n        table.add_row(\n            \"Total Data Transferred\",\n            format_bytes(\n                proxy_stats.total_bytes_sent + proxy_stats.total_bytes_received\n            ),\n        )\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(f\"SOCKS5 Proxy: {self.server_ip}:{self.port}\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(\n            table,\n            title=title,\n            subtitle=\"Press Ctrl+C to exit\",\n            border_style=\"blue\",\n            padding=(1, 2),\n        )\n\n    def run(self):\n        \"\"\"Run the UI with efficient updates.\"\"\"\n        try:\n            # Clear the screen once at start\n            console.clear()\n\n            # Create live display with higher refresh rate and auto refresh disabled\n            with Live(\n                self._generate_display(),\n                console=console,\n                refresh_per_second=4,  # Increased refresh rate\n                transient=False,  # Keep the display on screen\n                auto_refresh=False,  # Manual refresh control\n            ) as live:\n                while self.running:\n                    live.update(self._generate_display())\n                    time.sleep(self._refresh_rate)\n        except KeyboardInterrupt:\n            self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.ProxyUI-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.ProxyUI.__init__","title":"<code>__init__(server_ip, port=9050)</code>","text":"<p>Initialize the proxy UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>server_ip</code> <code>str</code> <p>IP address of the proxy server</p> required <code>port</code> <code>int</code> <p>Port number the proxy server is listening on (default: 9050)</p> <code>9050</code> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def __init__(self, server_ip: str, port: int = 9050) -&gt; None:\n    \"\"\"Initialize the proxy UI handler.\n\n    Args:\n        server_ip: IP address of the proxy server\n        port: Port number the proxy server is listening on (default: 9050)\n    \"\"\"\n    super().__init__()\n    self.server_ip = server_ip\n    self.port = port\n    self.running = True\n    self._last_bandwidth = 0\n    self._start_time = time.monotonic()\n    self._refresh_rate = 0.5\n    self._spinner = Spinner(\"dots\", text=\"\")\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.ProxyUI.run","title":"<code>run()</code>","text":"<p>Run the UI with efficient updates.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def run(self):\n    \"\"\"Run the UI with efficient updates.\"\"\"\n    try:\n        # Clear the screen once at start\n        console.clear()\n\n        # Create live display with higher refresh rate and auto refresh disabled\n        with Live(\n            self._generate_display(),\n            console=console,\n            refresh_per_second=4,  # Increased refresh rate\n            transient=False,  # Keep the display on screen\n            auto_refresh=False,  # Manual refresh control\n        ) as live:\n            while self.running:\n                live.update(self._generate_display())\n                time.sleep(self._refresh_rate)\n    except KeyboardInterrupt:\n        self.running = False\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/proxy_ui/#hotspot_socks_proxy.core.utils.prompt.proxy_ui.create_proxy_ui","title":"<code>create_proxy_ui(host, port)</code>","text":"<p>Create and return UI thread.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/proxy_ui.py</code> <pre><code>def create_proxy_ui(host: str, port: int) -&gt; threading.Thread | None:\n    \"\"\"Create and return UI thread.\"\"\"\n    ui = ProxyUI(host, port)\n    return threading.Thread(target=ui.run, daemon=True)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/","title":"hotspot_socks_proxy.core.utils.prompt.socks_ui","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui","title":"<code>hotspot_socks_proxy.core.utils.prompt.socks_ui</code>","text":"<p>SOCKS-specific UI components.</p>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui-classes","title":"Classes","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI","title":"<code>SocksUI</code>","text":"<p>               Bases: <code>PromptHandler</code></p> <p>UI handler for SOCKS connections.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>class SocksUI(PromptHandler):\n    \"\"\"UI handler for SOCKS connections.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SOCKS UI handler.\n\n        Sets up the spinner, start time, and active connections tracking.\n        \"\"\"\n        super().__init__()\n        self._spinner = Spinner(\"dots\", text=\"\")\n        self._start_time = time.monotonic()\n        self._active_connections = {}  # addr: start_time\n\n    def connection_started(self, addr: tuple):\n        \"\"\"Log new connection.\"\"\"\n        self._active_connections[addr] = time.monotonic()\n\n    def connection_ended(self, addr: tuple):\n        \"\"\"Log connection end.\"\"\"\n        self._active_connections.pop(addr, None)\n\n    def _generate_table(self) -&gt; Table:\n        \"\"\"Generate SOCKS statistics table.\"\"\"\n        table = Table(show_header=False, box=None, padding=(0, 1))\n        table.add_column(\"Property\", style=\"cyan\", no_wrap=True)\n        table.add_column(\"Value\", style=\"green\", no_wrap=True)\n\n        # Active connections\n        for addr, start_time in self._active_connections.items():\n            duration = time.monotonic() - start_time\n            table.add_row(f\"Connection {addr[0]}:{addr[1]}\", f\"{duration:.1f}s\")\n\n        # Connection stats\n        table.add_row(\"Total Connections\", str(len(self._active_connections)))\n\n        return table\n\n    def _generate_display(self) -&gt; Panel:\n        \"\"\"Generate the main display panel.\"\"\"\n        title = Text(\"SOCKS Connection Statistics\", style=\"bold cyan\")\n        table = self._generate_table()\n        return Panel(table, title=title, border_style=\"blue\", padding=(1, 2))\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI-functions","title":"Functions","text":""},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the SOCKS UI handler.</p> <p>Sets up the spinner, start time, and active connections tracking.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the SOCKS UI handler.\n\n    Sets up the spinner, start time, and active connections tracking.\n    \"\"\"\n    super().__init__()\n    self._spinner = Spinner(\"dots\", text=\"\")\n    self._start_time = time.monotonic()\n    self._active_connections = {}  # addr: start_time\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI.connection_ended","title":"<code>connection_ended(addr)</code>","text":"<p>Log connection end.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_ended(self, addr: tuple):\n    \"\"\"Log connection end.\"\"\"\n    self._active_connections.pop(addr, None)\n</code></pre>"},{"location":"reference/hotspot_socks_proxy/core/utils/prompt/socks_ui/#hotspot_socks_proxy.core.utils.prompt.socks_ui.SocksUI.connection_started","title":"<code>connection_started(addr)</code>","text":"<p>Log new connection.</p> Source code in <code>src/hotspot_socks_proxy/core/utils/prompt/socks_ui.py</code> <pre><code>def connection_started(self, addr: tuple):\n    \"\"\"Log new connection.\"\"\"\n    self._active_connections[addr] = time.monotonic()\n</code></pre>"}]}